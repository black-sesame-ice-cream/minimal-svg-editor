<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal SVG Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: 'Inter', sans-serif;
            overflow: hidden; 
        }
        textarea {
            font-family: monospace;
            outline: none;
            resize: none;
        }
        /* カラーピッカーのサイズを調整 */
        input[type="color"] {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        /* カラーピッカーのブラウザデフォルトスタイルを隠す (Chrome/Safari) */
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }
        /* カラーピッカーのブラウザデフォルトスタイルを隠す (Firefox) */
        input[type="color"]::-moz-focus-inner {
            border: 0;
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 4px;
        }
        /* プレビューエリアを相対配置（グリッドSVGを重ねるため） */
        #preview {
            position: relative;
            overflow: hidden;
        }
        /* プレビューコントロールバーの入力要素スタイル */
        .preview-input {
            padding: 0.375rem 0.5rem; /* p-1.5 と p-2 の中間 */
            border-radius: 0.375rem; /* rounded-md */
            border: none;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            outline: none;
        }
        .preview-input:focus {
            box-shadow: 0 0 0 2px var(--tw-ring-color, #3B82F6); /* focus:ring-2 focus:ring-blue-500 */
        }
        /* 明るい背景用の入力スタイル (デフォルト) */
        .preview-input-light {
            background-color: #E5E7EB; /* bg-gray-200 */
            color: #1F2937; /* text-gray-800 */
        }
        /* 暗い背景用の入力スタイル */
        .preview-input-dark {
            background-color: #374151; /* bg-gray-700 */
            color: #F9FAFB; /* text-gray-100 */
        }
        .github-icon-link {position: fixed; top: 4px; left: 4px; z-index: 999;}
        .github-icon-link img {width: 32px; height: 32px;}
        .github-icon-link:hover img {transform: scale(1.1);}
    </style>
</head>
<body class="bg-black flex flex-col">

    <div class="flex flex-col md:flex-row flex-grow">
        
        <!-- 左側: プレビューエリア -->
        <div id="preview-container" class="w-full md:w-1/2 h-1/2 md:h-full p-4 shadow-lg rounded-lg m-2 flex flex-col transition-colors duration-150">
            <!-- プレビュー コントロールバー -->
            <div id="preview-control-bar" class="flex items-center justify-start flex-wrap gap-x-4 gap-y-2 mb-2 p-2 rounded-md transition-colors duration-150">
                <!-- プレビュー背景色 -->
                <div class="flex items-center space-x-2">
                    <label for="preview-bg-color-picker" id="preview-bg-label" class="text-gray-600 text-sm font-medium">背景</label>
                    <input type="color" id="preview-bg-color-picker" title="プレビュー背景色を選択" value="#111827">
                </div>
                <!-- 補助線カラーピッカー -->
                <div class="flex items-center space-x-2">
                    <label for="grid-color-picker" id="grid-color-label" class="text-gray-600 text-sm font-medium">線色</label>
                    <input type="color" id="grid-color-picker" title="補助線と枠線の色を選択" value="#FFFFFF">
                </div>
                <!-- 補助線コントロール -->
                <div class="flex items-center space-x-2">
                    <label for="grid-cols-input" class="text-gray-600 text-sm font-medium">横分割</label>
                    <input type="number" id="grid-cols-input" min="1" max="32" value="2"
                           class="w-14 preview-input preview-input-light"
                           title="横の分割数 (1-32)">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="grid-rows-input" class="text-gray-600 text-sm font-medium">縦分割</label>
                    <input type="number" id="grid-rows-input" min="1" max="32" value="2"
                           class="w-14 preview-input preview-input-light"
                           title="縦の分割数 (1-32)">
                </div>
                <div class="flex items-center space-x-2">
                    <label for="grid-z-select" class="text-gray-600 text-sm font-medium">線</label>
                    <select id="grid-z-select" class="preview-input preview-input-light" title="補助線の前後">
                        <option value="back">背面</option>
                        <option value="front">前面</option>
                    </select>
                </div>
                <!-- ズームコントロール (非表示) -->
                <div class="flex items-center space-x-2 hidden">
                    <label id="preview-zoom-label" class="text-gray-600 text-sm font-medium">ズーム</label>
                    <button id="zoom-out-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-lg font-bold preview-input preview-input-light" title="縮小">-</button>
                    <button id="zoom-reset-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-sm preview-input preview-input-light" title="リセット">100%</button>
                    <button id="zoom-in-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-lg font-bold preview-input preview-input-light" title="拡大">+</button>
                </div>
            </div>
            
            <!-- プレビュー本体 -->
            <div id="preview" class="w-full h-full rounded-md p-2 transition-colors duration-150">
                <!-- パン・ズーム用のコンテナ (transform-origin: 0 0) -->
                <div id="svg-container" style="width: 100%; height: 100%; transform-origin: 0 0;">
                    <!-- ここにSVGがレンダリングされます -->
                </div>
            </div>
        </div>

        <!-- 右側: エディタエリア -->
        <div id="editor-container" class="w-full md:w-1/2 h-1/2 md:h-full p-4 shadow-lg rounded-lg m-2 flex flex-col transition-colors duration-150">
            <!-- コントロールバー: -->
            <div id="control-bar" class="flex items-center justify-start flex-wrap gap-x-4 gap-y-2 mb-2 p-2 rounded-md transition-colors duration-150">
                <!-- 背景色 -->
                <div class="flex items-center space-x-2">
                    <label for="bg-color-picker" class="text-gray-300 text-sm font-medium">背景</label>
                    <input type="color" id="bg-color-picker" title="背景色を選択" value="#111827">
                </div>
                <!-- 文字色 -->
                <div class="flex items-center space-x-2">
                    <label for="text-color-picker" class="text-gray-300 text-sm font-medium">文字</label>
                    <input type="color" id="text-color-picker" title="文字色を選択" value="#FFFFFF">
                </div>
                <!-- 文字サイズ -->
                <div class="flex items-center space-x-2">
                    <label for="font-size-input" class="text-gray-300 text-sm font-medium">サイズ</label>
                    <input type="number" id="font-size-input" min="8" max="64" value="14"
                           class="w-14 p-1.5 rounded-md bg-gray-700 text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                           title="フォントサイズ (8-64)">
                </div>
                <!-- SVG読み込みボタン -->
                <div class="flex items-center">
                    <input type="file" id="svg-file-input" accept="image/svg+xml,.svg" class="hidden">
                    <button id="load-svg-button" type="button"
                            class="px-3 py-1.5 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition-colors">
                        SVGを開く
                    </button>
                </div>
                <!-- SVG保存ボタン -->
                <div class="flex items-center">
                    <button id="save-svg-button" type="button"
                            class="px-3 py-1.5 bg-green-600 text-white text-sm font-medium rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition-colors">
                        SVGを保存
                    </button>
                </div>
                <!-- 最小化チェックボックス -->
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="minimize-svg-checkbox" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600 ring-offset-gray-800 focus:ring-2">
                    <label for="minimize-svg-checkbox" class="text-gray-300 text-sm font-medium">最小化</label>
                </div>
            </div>
            
            <!-- テキストエリア: -->
            <textarea id="svg-editor" 
                      class="w-full h-full p-4 rounded-md leading-relaxed" 
                      spellcheck="false">
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">

<defs>
	<linearGradient id="myGradient" x1="0%" y1="0%" x2="100%" y2="0%">
		<stop offset="0%" stop-color="#ff0000"/> 
		<stop offset="100%" stop-color="#ffff00"/> 
	</linearGradient>

	<pattern id="myPattern" width="20" height="20" patternUnits="userSpaceOnUse">
		<circle cx="10" cy="10" r="5" fill="url(#myGradient)"/>
	</pattern>
</defs>

<polygon points="50,5 61,40 98,40 68,62 79,96 50,75 21,96 32,62 2,40 39,40"
	fill="url(#myPattern)" stroke="#ff0" stroke-width="1" />

</svg></textarea>
        </div>
    </div>

    <a href="https://github.com/black-sesame-ice-cream/minimal-svg-editor" target="_blank" rel="noopener noreferrer" class="github-icon-link" title="View on GitHub">
        <img src="images/github-icon.svg" alt="GitHub" />
    </a>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            let scale = 1.0;
            let translateX = 0;
            let translateY = 0;
            let isPanning = false;
            let panStartX = 0;
            let panStartY = 0;

            const editor = document.getElementById('svg-editor');
            const preview = document.getElementById('preview');
            const svgContainer = document.getElementById('svg-container');
            
            const bgPicker = document.getElementById('bg-color-picker');
            const textColorPicker = document.getElementById('text-color-picker');
            const fontSizeInput = document.getElementById('font-size-input');
            const controlBar = document.getElementById('control-bar');
            const editorContainer = document.getElementById('editor-container');

            const minimizeCheckbox = document.getElementById('minimize-svg-checkbox');
            let originalSvgContent = ''; // 最小化前のSVGを保持

            const previewContainer = document.getElementById('preview-container');
            const previewControlBar = document.getElementById('preview-control-bar');
            const previewBgPicker = document.getElementById('preview-bg-color-picker');
            
            const gridColsInput = document.getElementById('grid-cols-input');
            const gridRowsInput = document.getElementById('grid-rows-input');
            const gridZSelect = document.getElementById('grid-z-select');
            const gridColorPicker = document.getElementById('grid-color-picker');
            
            // 補助線表示用のSVG要素を作成
            const gridSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            gridSvg.id = 'preview-grid-svg';
            gridSvg.style.position = 'absolute';
            gridSvg.style.top = '0';
            gridSvg.style.left = '0';
            gridSvg.style.width = '100%';
            gridSvg.style.height = '100%';
            gridSvg.style.pointerEvents = 'none'; // グリッドが操作を妨害しないように
            svgContainer.appendChild(gridSvg); 

            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomResetBtn = document.getElementById('zoom-reset-btn');

            /**
             * SVG文字列からコメントとタグ間の余分な空白・改行を削除します。
             * @param {string} svgString - 元のSVG文字列
             * @returns {string} - 最小化されたSVG文字列
             */
            function minifySvg(svgString) {
                if (typeof svgString !== 'string') return '';
                let minified = svgString;
                minified = minified.replace(/<!--[\s\S]*?-->/g, '');
                minified = minified.replace(/>\s*[\r\n]+\s*</g, '><'); // 改行を含む場合
                minified = minified.replace(/>\s+</g, '><'); // 改行を含まない空白のみの場合
                return minified.trim();
            }

            function applyPanZoom() {
                svgContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }

            // SVGを更新する関数 
            function updatePreview() {
                let svgCode = editor.value;
                
                let viewBoxValue = null;
                let preserveAspectRatioValue = null;
                let vbWidth = null;
                let vbHeight = null;
                let vbParts = null; 
                let newViewBoxValue = null; 

                let svgTagMatch = svgCode.match(/<svg([^>]*)>/i); 

                if (svgTagMatch) {
                    const svgTagAttributes = svgTagMatch[1]; 

                    const viewBoxMatch = svgTagAttributes.match(/viewBox="([^"]+)"/i);
                    if (viewBoxMatch) {
                        viewBoxValue = viewBoxMatch[1];
                    }

                    const preserveAspectRatioMatch = svgTagAttributes.match(/preserveAspectRatio="([^"]+)"/i);
                    if (preserveAspectRatioMatch) {
                        preserveAspectRatioValue = preserveAspectRatioMatch[1];
                    }

                    if (!viewBoxValue) {
                        const widthMatch = svgTagAttributes.match(/width="([^"]+)"/i);
                        const heightMatch = svgTagAttributes.match(/height="([^"]+)"/i);

                        if (widthMatch && /^[0-9.]+p?x?$/.test(widthMatch[1])) {
                            vbWidth = parseFloat(widthMatch[1]);
                        }
                        if (heightMatch && /^[0-9.]+p?x?$/.test(heightMatch[1])) {
                            vbHeight = parseFloat(heightMatch[1]);
                        }
                        
                        if (vbWidth && vbHeight) {
                            viewBoxValue = `0 0 ${vbWidth} ${vbHeight}`;
                        }
                    }
                    
                    if (viewBoxValue) {
                        vbParts = viewBoxValue.split(' ').map(Number);
                        if (vbParts.length === 4 && !isNaN(vbParts[2]) && !isNaN(vbParts[3])) {
                            const [vbX, vbY, vbWidth, vbHeight] = vbParts;
                            const newWidth = vbWidth * 2; 
                            const newHeight = vbHeight * 2;
                            const newX = vbX - (vbWidth * 0.5); 
                            const newY = vbY - (vbHeight * 0.5); 
                            newViewBoxValue = `${newX} ${newY} ${newWidth} ${newHeight}`;
                        } else {
                            viewBoxValue = null; 
                            vbParts = null;
                        }
                    }

                    let newAttributes = svgTagAttributes;
                    
                    newAttributes = newAttributes.replace(/width="[^"]+"/i, '');
                    newAttributes = newAttributes.replace(/height="[^"]+"/i, '');

                    if (newViewBoxValue) { 
                        if (viewBoxMatch) { 
                            newAttributes = newAttributes.replace(/viewBox="[^"]+"/i, `viewBox="${newViewBoxValue}"`);
                        } else { 
                            newAttributes += ` viewBox="${newViewBoxValue}"`;
                        }
                    } else if (viewBoxValue) {
                         if (viewBoxMatch) {
                            newAttributes = newAttributes.replace(/viewBox="[^"]+"/i, `viewBox="${viewBoxValue}"`);
                        } else {
                            newAttributes += ` viewBox="${viewBoxValue}"`;
                        }
                    }
                    
                    if (viewBoxValue && !preserveAspectRatioMatch) { 
                        preserveAspectRatioValue = 'xMidYMid meet'; 
                        newAttributes += ` preserveAspectRatio="${preserveAspectRatioValue}"`;
                    }
                    
                    svgCode = svgCode.replace(/<svg[^>]*>/i, `<svg${newAttributes}>`);
                }

                svgContainer.innerHTML = svgCode; 
                svgContainer.appendChild(gridSvg); 

                const svgElement = svgContainer.querySelector('svg:not(#preview-grid-svg)'); 
                
                if (!svgElement) {
                    gridSvg.innerHTML = '';
                    return;
                }
                
                svgElement.style.width = '100%';
                svgElement.style.height = '100%';
                gridSvg.style.width = '100%';
                gridSvg.style.height = '100%';

                try {
                    const gridColor = gridColorPicker.value; 

                    svgElement.style.position = 'absolute'; 
                    svgElement.style.top = '0';
                    svgElement.style.left = '0';
                    
                    if (!viewBoxValue || !vbParts || !newViewBoxValue) { 
                        gridSvg.innerHTML = ''; 
                        return;
                    }

                    const [vbX, vbY, vbWidth, vbHeight] = vbParts;

                    gridSvg.setAttribute('viewBox', newViewBoxValue);
                    
                    if (preserveAspectRatioValue) {
                        gridSvg.setAttribute('preserveAspectRatio', preserveAspectRatioValue);
                        svgElement.setAttribute('preserveAspectRatio', preserveAspectRatioValue); 
                    } else {
                        gridSvg.removeAttribute('preserveAspectRatio'); 
                        svgElement.removeAttribute('preserveAspectRatio');
                    }

                    const cols = Math.max(1, Math.min(32, parseInt(gridColsInput.value, 10) || 1));
                    const rows = Math.max(1, Math.min(32, parseInt(gridRowsInput.value, 10) || 1));
                    const zIndexOption = gridZSelect.value;
                    
                    let pathD = '';
                    if (cols > 1) {
                        for (let i = 1; i < cols; i++) {
                            const x = vbX + (vbWidth / cols) * i;
                            pathD += `M ${x} ${vbY} V ${vbY + vbHeight} `; 
                        }
                    }
                    if (rows > 1) {
                        for (let j = 1; j < rows; j++) {
                            const y = vbY + (vbHeight / rows) * j;
                            pathD += `M ${vbX} ${y} H ${vbX + vbWidth} `; 
                        }
                    }
                    const strokeWidth = 1;
                    const borderPathD = `M ${vbX} ${vbY} H ${vbX + vbWidth} V ${vbY + vbHeight} H ${vbX} Z`;
                    gridSvg.innerHTML = `<path d="${borderPathD} ${pathD}" stroke="${gridColor}" stroke-width="${strokeWidth}" fill="none" vector-effect="non-scaling-stroke" />`;

                    if (zIndexOption === 'back') {
                        svgElement.style.zIndex = '10';
                        gridSvg.style.zIndex = '0';
                    } else {
                        svgElement.style.zIndex = '0';
                        gridSvg.style.zIndex = '10';
                    }

                } catch (e) {
                    console.error("Failed to apply viewBox border or grid: ", e);
                    gridSvg.innerHTML = ''; 
                }
            }

            // コード補完機能 
            const snippets = {
                '<svg': '<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">\n\t\n</svg>',
                '<r': '<rect x="" y="" width="" height="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<c': '<circle cx="" cy="" r="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<e': '<ellipse cx="" cy="" rx="" ry="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<l': '<line x1="" y1="" x2="" y2="" stroke="#000" stroke-width=""/>',
                '<pl': '<polyline points="" fill="none" stroke="#000" stroke-width=""/>',
                '<pg': '<polygon points="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<p': '<path d="" fill="none" stroke="#000" stroke-width=""/>',
                '<t': '<text x="" y="" fill="#000" font-size="">text</text>',
                '<g': '<g>\n\t\n</g>',
                '<defs': '<defs>\n\t\n</defs>',
                '<lg': '<linearGradient id="" x1="0%" y1="0%" x2="100%" y2="0%">\n\t<stop offset="0%" stop-color="" />\n\t<stop offset="100%" stop-color="" />\n</linearGradient>',
                '<rg': '<radialGradient id="" cx="50%" cy="50%" r="50%">\n\t<stop offset="0%" stop-color="" />\n\t<stop offset="100%" stop-color="" />\n</radialGradient>',
                '<ptn': '<pattern id="" width="" height="" patternUnits="userSpaceOnUse">\n\t\n</pattern>',
                '<use': '<use href="#id" x="" y=""/>'
            };

            editor.addEventListener('keydown', (e) => {
                if (editor.readOnly) return;

                if (e.key === 'Tab' || e.key === 'Enter') {
                    const start = editor.selectionStart;
                    const textBefore = editor.value.substring(0, start);
                    let triggerKey = null;
                    for (const key of Object.keys(snippets)) {
                        if (textBefore.endsWith(key)) {
                            triggerKey = key;
                            break; 
                        }
                    }

                    if (triggerKey) {
                        e.preventDefault(); 
                        const snippetValue = snippets[triggerKey];
                        const newTextBefore = textBefore.substring(0, textBefore.length - triggerKey.length);
                        const textAfter = editor.value.substring(start);
                        
                        editor.value = newTextBefore + snippetValue + textAfter;

                        const firstQuoteIndex = snippetValue.indexOf('""');
                        let newCursorPos;
                        if (firstQuoteIndex !== -1) {
                            newCursorPos = newTextBefore.length + firstQuoteIndex + 1;
                        } else {
                            newCursorPos = newTextBefore.length + snippetValue.length; 
                        }
                        editor.selectionStart = editor.selectionEnd = newCursorPos;
                        updatePreview(); 
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        const end = editor.selectionEnd;
                        editor.value = editor.value.substring(0, start) + '\t' + editor.value.substring(end);
                        editor.selectionStart = editor.selectionEnd = start + 1;
                        updatePreview();
                    }
                }
            });

            editor.addEventListener('input', () => {
                if (editor.readOnly) return;
                updatePreview();
            });
            
            // ページ読み込み時に最初のプレビューを実行
            updatePreview();

            /**
             * HEXコードを明るくする関数
             * @param {string} hex - #RRGGBB 形式のHEXカラーコード
             * @param {number} percent - 明るくする割合 (例: 20 は 20% 明るくする)
             * @returns {string} - 明るくした #RRGGBB カラーコード
             */
            function lightenHexColor(hex, percent) {
                let r = parseInt(hex.slice(1, 3), 16);
                let g = parseInt(hex.slice(3, 5), 16);
                let b = parseInt(hex.slice(5, 7), 16);
                r = Math.min(255, Math.floor(r + (255 - r) * (percent / 100)));
                g = Math.min(255, Math.floor(g + (255 - g) * (percent / 100)));
                b = Math.min(255, Math.floor(b + (255 - b) * (percent / 100)));
                const rHex = r.toString(16).padStart(2, '0');
                const gHex = g.toString(16).padStart(2, '0');
                const bHex = b.toString(16).padStart(2, '0');
                return `#${rHex}${gHex}${bHex}`;
            }

            /**
             * HEXコードを暗くする関数
             * @param {string} hex - #RRGGBB 形式のHEXカラーコード
             * @param {number} percent - 暗くする割合 (例: 20 は 20% 暗くする)
             * @returns {string} - 暗くした #RRGGBB カラーコード
             */
            function darkenHexColor(hex, percent) {
                let r = parseInt(hex.slice(1, 3), 16);
                let g = parseInt(hex.slice(3, 5), 16);
                let b = parseInt(hex.slice(5, 7), 16);
                r = Math.max(0, Math.floor(r * (1 - percent / 100)));
                g = Math.max(0, Math.floor(g * (1 - percent / 100)));
                b = Math.max(0, Math.floor(b * (1 - percent / 100)));
                const rHex = r.toString(16).padStart(2, '0');
                const gHex = g.toString(16).padStart(2, '0');
                const bHex = b.toString(16).padStart(2, '0');
                return `#${rHex}${gHex}${bHex}`;
            }

            // 背景色とコントロールバー、座布団の色の設定
            function setEditorBackground(color) {
                editor.style.backgroundColor = color; 
                try {
                    const lighterColor = lightenHexColor(color, 20);
                    controlBar.style.backgroundColor = lighterColor;
                    editorContainer.style.backgroundColor = lighterColor;

                    const labels = controlBar.querySelectorAll('label');
                    let r = parseInt(lighterColor.slice(1, 3), 16);
                    let g = parseInt(lighterColor.slice(3, 5), 16);
                    let b = parseInt(lighterColor.slice(5, 7), 16);
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;

                    labels.forEach(label => {
                        label.classList.remove('text-gray-300', 'text-gray-700'); 
                        if (brightness < 128) { 
                            label.classList.add('text-gray-300'); 
                        } else { 
                            label.classList.add('text-gray-700'); 
                        }
                    });
                } catch (e) {
                    console.error("Failed to lighten color: ", e);
                    controlBar.style.backgroundColor = "#ffffff"; 
                    editorContainer.style.backgroundColor = "#ffffff";
                }
            }

            // プレビュー背景色の設定 (プレビュー本体 + 座布団/コントロールバー)
            function setPreviewBackground(color) {
                preview.style.backgroundColor = color; 
                try {
                    const lighterColor = lightenHexColor(color, 20); 
                    previewControlBar.style.backgroundColor = lighterColor; 
                    previewContainer.style.backgroundColor = lighterColor; 

                    const labels = previewControlBar.querySelectorAll('label');
                    const controls = previewControlBar.querySelectorAll('.preview-input, .zoom-btn'); 

                    if (labels.length > 0) {
                        let r = parseInt(lighterColor.slice(1, 3), 16);
                        let g = parseInt(lighterColor.slice(3, 5), 16);
                        let b = parseInt(lighterColor.slice(5, 7), 16);
                        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                        
                        labels.forEach(label => {
                            label.classList.remove('text-gray-600', 'text-gray-100'); 
                            if (brightness < 128) { 
                                label.classList.add('text-gray-100'); 
                            } else { 
                                label.classList.add('text-gray-600'); 
                            }
                        });

                        controls.forEach(control => {
                            control.classList.remove('preview-input-light', 'preview-input-dark');
                            if (brightness < 128) { 
                                control.classList.add('preview-input-dark');
                            } else { 
                                control.classList.add('preview-input-light');
                            }
                        });
                    }
                } catch (e) {
                    console.error("Failed to lighten color: ", e); 
                    previewControlBar.style.backgroundColor = "#f3f4f6"; 
                    previewContainer.style.backgroundColor = "#f3f4f6";
                }
            }

            // 文字色の設定
            function setEditorTextColor(color) {
                editor.style.color = color;
            }

            // 文字サイズの設定
            function setEditorFontSize(size) {
                const safeSize = parseInt(size, 10);
                if (safeSize >= 8 && safeSize <= 64) {
                    editor.style.fontSize = `${safeSize}px`;
                } else if (!safeSize) {
                     editor.style.fontSize = '14px'; // 空の場合のデフォルト
                }
            }

            // イベントリスナーを設定
            bgPicker.addEventListener('input', (e) => {
                setEditorBackground(e.target.value);
            });

            textColorPicker.addEventListener('input', (e) => {
                if (minimizeCheckbox.checked) {
                    try {
                        editor.style.color = darkenHexColor(e.target.value, 20);
                    } catch (err) {
                        editor.style.color = e.target.value; 
                    }
                } else {
                    setEditorTextColor(e.target.value);
                }
            });

            fontSizeInput.addEventListener('input', (e) => {
                setEditorFontSize(e.target.value);
            });

            // プレビュー背景色用のイベントリスナー
            previewBgPicker.addEventListener('input', (e) => {
                setPreviewBackground(e.target.value);
                updatePreview(); 
            });

            // グリッドコントロールのイベントリスナー
            gridColsInput.addEventListener('input', updatePreview);
            gridRowsInput.addEventListener('input', updatePreview);
            gridZSelect.addEventListener('change', updatePreview);
            gridColorPicker.addEventListener('input', updatePreview); 

            // ズーム機能
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    scale = parseFloat((scale + 0.1).toFixed(2));
                    applyPanZoom();
                });
            }
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    scale = parseFloat(Math.max(0.1, scale - 0.1).toFixed(2));
                    applyPanZoom();
                });
            }
            if (zoomResetBtn) {
                zoomResetBtn.addEventListener('click', () => {
                    scale = 1.0;
                    translateX = 0;
                    translateY = 0;
                    applyPanZoom();
                });
            }

            // ホイールズーム (マウスカーソル中心)
            preview.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const newScale = parseFloat(Math.max(0.1, scale + delta).toFixed(2));
                
                const rect = preview.getBoundingClientRect();
                const mouseX = e.clientX - rect.left; 
                const mouseY = e.clientY - rect.top; 

                const targetX = (mouseX - translateX) / scale;
                const targetY = (mouseY - translateY) / scale;
                
                translateX = mouseX - targetX * newScale;
                translateY = mouseY - targetY * newScale;
                scale = newScale;
                
                applyPanZoom();
            });

            // パン (ドラッグ)
            preview.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                isPanning = true;
                panStartX = e.clientX - translateX;
                panStartY = e.clientY - translateY;
                preview.style.cursor = 'grabbing';
            });
            preview.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                translateX = e.clientX - panStartX;
                translateY = e.clientY - panStartY;
                applyPanZoom();
            });
            preview.addEventListener('mouseup', () => {
                isPanning = false;
                preview.style.cursor = 'default';
            });
            preview.addEventListener('mouseleave', () => {
                isPanning = false;
                preview.style.cursor = 'default';
            });

            // 初期スタイルの適用
            setEditorBackground(bgPicker.value);
            setEditorTextColor(textColorPicker.value);
            setEditorFontSize(fontSizeInput.value);
            setPreviewBackground(previewBgPicker.value); 

            // SVGファイル読み込み機能
            const loadButton = document.getElementById('load-svg-button');
            const fileInput = document.getElementById('svg-file-input');

            loadButton.addEventListener('click', () => {
                fileInput.click(); 
            });

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const svgContent = e.target.result;
                        editor.value = svgContent; 
                        
                        if (minimizeCheckbox.checked) {
                            minimizeCheckbox.checked = false;
                            editor.readOnly = false;
                            setEditorTextColor(textColorPicker.value); 
                        }
                        updatePreview(); 
                    };
                    reader.readAsText(file);
                }
                event.target.value = null; 
            });
            
            // SVGファイル保存機能
            const saveButton = document.getElementById('save-svg-button');

            saveButton.addEventListener('click', () => {
                const svgContent = editor.value;
                const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'edited.svg'; 
                document.body.appendChild(a); 
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            // 最小化機能
            minimizeCheckbox.addEventListener('change', () => {
                if (minimizeCheckbox.checked) {
                    originalSvgContent = editor.value;
                    editor.value = minifySvg(originalSvgContent);
                    editor.readOnly = true;
                    try {
                        editor.style.color = darkenHexColor(textColorPicker.value, 20);
                    } catch (e) {
                        editor.style.color = textColorPicker.value;
                        console.error("Failed to darken color on minimize:", e);
                    }
                    updatePreview();
                } else {
                    editor.value = originalSvgContent;
                    editor.readOnly = false;
                    setEditorTextColor(textColorPicker.value);
                    updatePreview();
                }
            });

        });
    </script>

</body>
</html>

