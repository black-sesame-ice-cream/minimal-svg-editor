<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal SVG Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: 'Inter', sans-serif;
            overflow: hidden; 
        }

        textarea {
            font-family: monospace;
            outline: none;
            resize: none;
        }
        /* カラーピッカーのサイズを調整 */
        input[type="color"] {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        /* カラーピッカーのブラウザデフォルトスタイルを隠す (Chrome/Safari) */
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }
        /* カラーピッカーのブラウザデフォルトスタイルを隠す (Firefox) */
        input[type="color"]::-moz-focus-inner {
            border: 0;
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 4px;
        }
        
        /* プレビューエリアを相対配置（グリッドSVGを重ねるため） */
        #preview {
            position: relative;
            overflow: hidden;
        }

        /* プレビューコントロールバーの入力要素スタイル */
        .preview-input {
            padding: 0.375rem 0.5rem; /* p-1.5 と p-2 の中間 */
            border-radius: 0.375rem; /* rounded-md */
            border: none;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            outline: none;
        }
        .preview-input:focus {
            box-shadow: 0 0 0 2px var(--tw-ring-color, #3B82F6); /* focus:ring-2 focus:ring-blue-500 */
        }
        
        /* 明るい背景用の入力スタイル (デフォルト) */
        .preview-input-light {
            background-color: #E5E7EB; /* bg-gray-200 */
            color: #1F2937; /* text-gray-800 */
        }
        
        /* 暗い背景用の入力スタイル */
        .preview-input-dark {
            background-color: #374151; /* bg-gray-700 */
            color: #F9FAFB; /* text-gray-100 */
        }

        .github-icon-link {position: fixed; top: 4px; left: 4px; z-index: 999;}
        .github-icon-link img {width: 32px; height: 32px;}
        .github-icon-link:hover img {transform: scale(1.1);}

    </style>
</head>
<!-- (変更) body に flex flex-col を追加し、背景色を bg-black に変更 -->
<body class="bg-black flex flex-col">

    <!-- (変更) h-screen を flex-grow に変更し、ヘッダーの分だけ高さを調整 -->
    <div class="flex flex-col md:flex-row flex-grow">
        
        <!-- 左側: プレビューエリア -->
        <div id="preview-container" class="w-full md:w-1/2 h-1/2 md:h-full p-4 shadow-lg rounded-lg m-2 flex flex-col transition-colors duration-150">
            <!-- プレビュー コントロールバー -->
            <div id="preview-control-bar" class="flex items-center justify-start flex-wrap gap-x-4 gap-y-2 mb-2 p-2 rounded-md transition-colors duration-150">
                <!-- プレビュー背景色 -->
                <div class="flex items-center space-x-2">
                    <!-- label に id を追加 -->
                    <label for="preview-bg-color-picker" id="preview-bg-label" class="text-gray-600 text-sm font-medium">背景</label>
                    <!-- 初期値を設定 (白) -->
                    <input type="color" id="preview-bg-color-picker" title="プレビュー背景色を選択" value="#111827">
                </div>

                <!-- 補助線カラーピッカー -->
                <div class="flex items-center space-x-2">
                    <label for="grid-color-picker" id="grid-color-label" class="text-gray-600 text-sm font-medium">線色</label>
                    <input type="color" id="grid-color-picker" title="補助線と枠線の色を選択" value="#FFFFFF">
                </div>

                <!-- 補助線コントロール -->
                <div class="flex items-center space-x-2">
                    <label for="grid-cols-input" class="text-gray-600 text-sm font-medium">横分割</label>
                    <input type="number" id="grid-cols-input" min="1" max="32" value="2"
                           class="w-14 preview-input preview-input-light"
                           title="横の分割数 (1-32)">
                </div>
                
                <div class="flex items-center space-x-2">
                    <label for="grid-rows-input" class="text-gray-600 text-sm font-medium">縦分割</label>
                    <input type="number" id="grid-rows-input" min="1" max="32" value="2"
                           class="w-14 preview-input preview-input-light"
                           title="縦の分割数 (1-32)">
                </div>

                <div class="flex items-center space-x-2">
                    <label for="grid-z-select" class="text-gray-600 text-sm font-medium">線</label>
                    <select id="grid-z-select" class="preview-input preview-input-light" title="補助線の前後">
                        <option value="back">背面</option>
                        <option value="front">前面</option>
                    </select>
                </div>
                <!-- (ここまで追加) -->
                
                <!-- ズームコントロール (復活) -->
                <div class="flex items-center space-x-2 hidden">
                    <label id="preview-zoom-label" class="text-gray-600 text-sm font-medium">ズーム</label>
                    <button id="zoom-out-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-lg font-bold preview-input preview-input-light" title="縮小">-</button>
                    <button id="zoom-reset-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-sm preview-input preview-input-light" title="リセット">100%</button>
                    <button id="zoom-in-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-lg font-bold preview-input preview-input-light" title="拡大">+</button>
                </div>

            </div>
            
            <!-- プレビュー本体 -->
            <div id="preview" class="w-full h-full rounded-md p-2 transition-colors duration-150">
                <!-- パン・ズーム用のコンテナ (transform-origin: 0 0) -->
                <div id="svg-container" style="width: 100%; height: 100%; transform-origin: 0 0;">
                    <!-- ここにSVGがレンダリングされます -->
                </div>
            </div>
        </div>

        <!-- 右側: エディタエリア -->
        <div id="editor-container" class="w-full md:w-1/2 h-1/2 md:h-full p-4 shadow-lg rounded-lg m-2 flex flex-col transition-colors duration-150">
            <!-- コントロールバー: -->
            <div id="control-bar" class="flex items-center justify-start flex-wrap gap-x-4 gap-y-2 mb-2 p-2 rounded-md transition-colors duration-150">
                
                <!-- 背景色 -->
                <div class="flex items-center space-x-2">
                    <label for="bg-color-picker" class="text-gray-300 text-sm font-medium">背景</label>
                    <!-- 初期値を設定 (Tailwindのbg-gray-900) -->
                    <input type="color" id="bg-color-picker" title="背景色を選択" value="#111827">
                </div>

                <!-- 文字色 -->
                <div class="flex items-center space-x-2">
                    <label for="text-color-picker" class="text-gray-300 text-sm font-medium">文字</label>
                    <!-- 初期値を設定 (Tailwindのtext-green-400) -->
                    <input type="color" id="text-color-picker" title="文字色を選択" value="#FFFFFF">
                </div>

                <!-- 文字サイズ -->
                <div class="flex items-center space-x-2">
                    <label for="font-size-input" class="text-gray-300 text-sm font-medium">サイズ</label>
                    <!-- 初期値を設定 (Tailwindのtext-smは14px) -->
                    <input type="number" id="font-size-input" min="8" max="64" value="14"
                           class="w-14 p-1.5 rounded-md bg-gray-700 text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                           title="フォントサイズ (8-64)">
                </div>

                <!-- SVG読み込みボタン -->
                <div class="flex items-center">
                    <input type="file" id="svg-file-input" accept="image/svg+xml,.svg" class="hidden">
                    <button id="load-svg-button" type="button"
                            class="px-3 py-1.5 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition-colors">
                        SVGを開く
                    </button>
                </div>

                <!-- (ここから追加) SVG保存ボタン -->
                <div class="flex items-center">
                    <button id="save-svg-button" type="button"
                            class="px-3 py-1.5 bg-green-600 text-white text-sm font-medium rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition-colors">
                        SVGを保存
                    </button>
                </div>

                <!-- 最小化チェックボックス -->
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="minimize-svg-checkbox" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600 ring-offset-gray-800 focus:ring-2">
                    <label for="minimize-svg-checkbox" class="text-gray-300 text-sm font-medium">最小化</label>
                </div>

            </div>
            
            <!-- テキストエリア: -->
            <textarea id="svg-editor" 
                      class="w-full h-full p-4 rounded-md leading-relaxed" 
                      spellcheck="false">
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">

<circle cx="50" cy="50" r="45" fill="#30cb80" stroke="pink" stroke-width="3" />

<rect x="30" y="30" width="40" height="40" fill="rgba(255, 255, 0, 0.7)" />

<text x="50" y="55" font-size="10" text-anchor="middle" fill="black">
SVG
</text>

</svg></textarea>
        </div>
    </div>

    <a href="https://github.com/black-sesame-ice-cream/minimal-svg-editor" target="_blank" rel="noopener noreferrer" class="github-icon-link" title="View on GitHub">
        <img src="images/github-icon.svg" alt="GitHub" />
    </a>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- ズーム状態を保持 ---
            let scale = 1.0;
            let translateX = 0;
            let translateY = 0;
            let isPanning = false;
            let panStartX = 0;
            let panStartY = 0;

            const editor = document.getElementById('svg-editor');
            const preview = document.getElementById('preview');
            const svgContainer = document.getElementById('svg-container');
            
            // --- エディタ設定用 ---
            const bgPicker = document.getElementById('bg-color-picker');
            const textColorPicker = document.getElementById('text-color-picker');
            const fontSizeInput = document.getElementById('font-size-input');
            const controlBar = document.getElementById('control-bar'); // コントロールバーを取得
            const editorContainer = document.getElementById('editor-container'); // エディタコンテナ（座布団）を取得

            // 最小化チェックボックスと元のコード保持用
            const minimizeCheckbox = document.getElementById('minimize-svg-checkbox');
            let originalSvgContent = ''; // 最小化前のSVGを保持

            // --- プレビュー設定用 ---
            const previewContainer = document.getElementById('preview-container');
            const previewControlBar = document.getElementById('preview-control-bar');
            const previewBgPicker = document.getElementById('preview-bg-color-picker');
            // (preview は SVGプレビュー用で取得済み)
            
            // 補助線コントロール用
            const gridColsInput = document.getElementById('grid-cols-input');
            const gridRowsInput = document.getElementById('grid-rows-input');
            const gridZSelect = document.getElementById('grid-z-select');
            const gridColorPicker = document.getElementById('grid-color-picker'); // (追加)
            
            // 補助線表示用のSVG要素を作成
            const gridSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            gridSvg.id = 'preview-grid-svg';
            // スタイルを設定 (絶対配置で重ねる)
            gridSvg.style.position = 'absolute';
            gridSvg.style.top = '0';
            gridSvg.style.left = '0';
            gridSvg.style.width = '100%';
            gridSvg.style.height = '100%';
            gridSvg.style.pointerEvents = 'none'; // グリッドが操作を妨害しないように
            svgContainer.appendChild(gridSvg); 


            // --- ズームボタン (復活) ---
            // ※ボタンはHTML側で非表示になっていますが、念のためIDで取得しておきます
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const zoomResetBtn = document.getElementById('zoom-reset-btn');

            // --- SVGプレビュー用 ---

            // 最小化関数
            /**
             * SVG文字列からコメントとタグ間の余分な空白・改行を削除します。
             * @param {string} svgString - 元のSVG文字列
             * @returns {string} - 最小化されたSVG文字列
             */
            function minifySvg(svgString) {
                if (typeof svgString !== 'string') return '';
                
                let minified = svgString;
                
                // 1. コメント (<!-- ... -->) を削除
                minified = minified.replace(/<!--[\s\S]*?-->/g, '');
                
                // 2. タグ間の空白・改行 ( > ... < ) を削除
                //    (改行、タブ、スペースを効率的に削除)
                minified = minified.replace(/>\s*[\r\n]+\s*</g, '><'); // 改行を含む場合
                minified = minified.replace(/>\s+</g, '><'); // 改行を含まない空白のみの場合
                
                return minified.trim();
            }

            // (追加) パン・ズームを適用する関数
            function applyPanZoom() {
                svgContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }

            // SVGを更新する関数 
            function updatePreview() {
                let svgCode = editor.value;
                
                // svgCodeをパースして viewBox, width, height を処理
                let viewBoxValue = null;
                let preserveAspectRatioValue = null;
                let vbWidth = null;
                let vbHeight = null;
                let svgTagMatch = svgCode.match(/<svg([^>]*)>/i); // 大文字小文字無視

                if (svgTagMatch) {
                    const svgTagAttributes = svgTagMatch[1]; // <svg ...> の ... の部分

                    // 1. viewBox を探す
                    const viewBoxMatch = svgTagAttributes.match(/viewBox="([^"]+)"/i);
                    if (viewBoxMatch) {
                        viewBoxValue = viewBoxMatch[1];
                    }

                    // 2. preserveAspectRatio を探す
                    const preserveAspectRatioMatch = svgTagAttributes.match(/preserveAspectRatio="([^"]+)"/i);
                    if (preserveAspectRatioMatch) {
                        preserveAspectRatioValue = preserveAspectRatioMatch[1];
                    }

                    // 3. viewBox がない場合、width/height を探す
                    if (!viewBoxValue) {
                        const widthMatch = svgTagAttributes.match(/width="([^"]+)"/i);
                        const heightMatch = svgTagAttributes.match(/height="([^"]+)"/i);

                        // 単純な数値（単位なし or px）のみを対象とする
                        if (widthMatch && /^[0-9.]+p?x?$/.test(widthMatch[1])) {
                            vbWidth = parseFloat(widthMatch[1]);
                        }
                        if (heightMatch && /^[0-9.]+p?x?$/.test(heightMatch[1])) {
                            vbHeight = parseFloat(heightMatch[1]);
                        }
                        
                        // width/height から viewBox を生成
                        if (vbWidth && vbHeight) {
                            viewBoxValue = `0 0 ${vbWidth} ${vbHeight}`;
                        }
                    }

                    // 4. svgCode を書き換える (width/height属性を削除し、viewBox/preserveAspectRatioを追加/置換)
                    let newAttributes = svgTagAttributes;
                    
                    // width/height を削除
                    newAttributes = newAttributes.replace(/width="[^"]+"/i, '');
                    newAttributes = newAttributes.replace(/height="[^"]+"/i, '');

                    // viewBox を追加/置換
                    if (viewBoxValue) {
                        if (viewBoxMatch) { // 元々 viewBox があった場合
                            newAttributes = newAttributes.replace(/viewBox="[^"]+"/i, `viewBox="${viewBoxValue}"`);
                        } else { // viewBox を新しく生成した場合
                            newAttributes += ` viewBox="${viewBoxValue}"`;
                        }
                    }
                    
                    // preserveAspectRatio を追加 (viewBox があり、かつ preserveAspectRatio が指定されていなかった場合)
                    if (viewBoxValue && !preserveAspectRatioMatch) {
                        preserveAspectRatioValue = 'xMidYMid meet'; // デフォルト値を明示的に設定
                        newAttributes += ` preserveAspectRatio="${preserveAspectRatioValue}"`;
                    }
                    // (元々 preserveAspectRatio があった場合は、その値 (preserveAspectRatioValue) がそのまま使われる)
                    
                    // svg タグ全体を置換
                    svgCode = svgCode.replace(/<svg[^>]*>/i, `<svg${newAttributes}>`);
                }

                // ユーザーSVGを挿入 (変更: preview -> svgContainer, (変更) 加工済みの svgCode を使用)
                svgContainer.innerHTML = svgCode; 
                
                // グリッドSVGが innerHTML で消されるため再追加 (変更: preview -> svgContainer)
                svgContainer.appendChild(gridSvg); 

                // ユーザーが挿入したSVG要素を取得 (変更: preview -> svgContainer)
                const svgElement = svgContainer.querySelector('svg:not(#preview-grid-svg)');
                
                // グリッドSVGの中身をクリア（SVG要素がない場合）
                if (!svgElement) {
                    gridSvg.innerHTML = '';
                    return;
                }
                
                svgElement.style.width = '100%';
                svgElement.style.height = '100%';
                gridSvg.style.width = '100%';
                gridSvg.style.height = '100%';


                try {
                    const gridColor = gridColorPicker.value; // (追加) グリッドカラーピッカーから色を取得

                    // --- 1. ユーザーSVGの処理 ---
                    svgElement.style.position = 'absolute'; 
                    svgElement.style.top = '0';
                    svgElement.style.left = '0';
                    
                    // --- 2. グリッドSVGの処理 ---                    
                    if (!viewBoxValue) { 
                        gridSvg.innerHTML = ''; // viewBoxがなければグリッドも描画しない
                        return;
                    }
                    
                    // ユーザーSVGのviewBoxとアスペクト比をグリッドSVGに同期
                    gridSvg.setAttribute('viewBox', viewBoxValue);
                    // (変更) 既に取得済みの preserveAspectRatioValue を使う (null の場合はデフォルト動作)
                    if (preserveAspectRatioValue) {
                        gridSvg.setAttribute('preserveAspectRatio', preserveAspectRatioValue);
                    } else {
                        // preserveAspectRatio 属性がなければ削除 (デフォルト動作 xMidYMid meet になる)
                        gridSvg.removeAttribute('preserveAspectRatio'); 
                    }

                    // viewBoxの値 (minX, minY, width, height) をパース
                    const vbParts = viewBoxValue.split(' ').map(Number);
                    if (vbParts.length !== 4 || isNaN(vbParts[2]) || isNaN(vbParts[3])) {
                        gridSvg.innerHTML = ''; // 不正なviewBox
                        return;
                    }
                    const [vbX, vbY, vbWidth, vbHeight] = vbParts;

                    // グリッド設定を取得
                    const cols = Math.max(1, Math.min(32, parseInt(gridColsInput.value, 10) || 1));
                    const rows = Math.max(1, Math.min(32, parseInt(gridRowsInput.value, 10) || 1));
                    const zIndexOption = gridZSelect.value;
                    
                    // グリッド線のパス(d属性)を構築
                    let pathD = '';
                    // 垂直線
                    if (cols > 1) {
                        for (let i = 1; i < cols; i++) {
                            const x = vbX + (vbWidth / cols) * i;
                            pathD += `M ${x} ${vbY} V ${vbY + vbHeight} `; // (修正) L -> V (Vertical line)
                        }
                    }
                    // 水平線
                    if (rows > 1) {
                        for (let j = 1; j < rows; j++) {
                            const y = vbY + (vbHeight / rows) * j;
                            pathD += `M ${vbX} ${y} H ${vbX + vbWidth} `; // (修正) L -> H (Horizontal line)
                        }
                    }
                    
                    // グリッド線の太さをviewBox基準で計算 (100x100のとき0.5程度になるように)
                    // const strokeWidth = (vbWidth + vbHeight) / 400; 
                    const strokeWidth = 1; // (変更) non-scaling-stroke を使うため、ピクセル相当の固定値に変更
                    
                    // (追加) viewBoxの枠線パス
                    const borderPathD = `M ${vbX} ${vbY} H ${vbX + vbWidth} V ${vbY + vbHeight} H ${vbX} Z`;

                    // グリッドSVGの中身を更新
                    // (変更) 枠線パス(borderPathD)とグリッド線パス(pathD)を結合し、gridColor を使用
                    gridSvg.innerHTML = `<path d="${borderPathD} ${pathD}" stroke="${gridColor}" stroke-width="${strokeWidth}" fill="none" vector-effect="non-scaling-stroke" />`;


                    // --- 3. Z-index（前後）の処理 ---
                    if (zIndexOption === 'back') {
                        // 線を後ろ
                        svgElement.style.zIndex = '10';
                        gridSvg.style.zIndex = '0';
                    } else {
                        // 線を前
                        svgElement.style.zIndex = '0';
                        gridSvg.style.zIndex = '10';
                    }

                } catch (e) {
                    console.error("Failed to apply viewBox border or grid: ", e);
                    gridSvg.innerHTML = ''; // エラー時はグリッドをクリア
                }
            }

            // テキストエリアの入力イベント
            editor.addEventListener('input', () => {
                // 最小化中は入力イベントを無視 (readOnlyだが念のため)
                if (editor.readOnly) return;
                
                // 編集可能時のみプレビューを更新
                updatePreview();
            });

            // ページ読み込み時に最初のプレビューを実行
            updatePreview();

            // --- ここからエディタスタイル設定 ---{
            /**
             * HEXコードを明るくする関数
             * @param {string} hex - #RRGGBB 形式のHEXカラーコード
             * @param {number} percent - 明るくする割合 (例: 20 は 20% 明るくする)
             * @returns {string} - 明るくした #RRGGBB カラーコード
             */
            function lightenHexColor(hex, percent) {
                // # を取り除く
                let r = parseInt(hex.slice(1, 3), 16);
                let g = parseInt(hex.slice(3, 5), 16);
                let b = parseInt(hex.slice(5, 7), 16);

                // 各色を明るくする (255に近づける)
                r = Math.min(255, Math.floor(r + (255 - r) * (percent / 100)));
                g = Math.min(255, Math.floor(g + (255 - g) * (percent / 100)));
                b = Math.min(255, Math.floor(b + (255 - b) * (percent / 100)));

                // HEXに戻す (各値が1桁の場合に0でパディング)
                const rHex = r.toString(16).padStart(2, '0');
                const gHex = g.toString(16).padStart(2, '0');
                const bHex = b.toString(16).padStart(2, '0');

                return `#${rHex}${gHex}${bHex}`;
            }

            /**
             * HEXコードを暗くする関数
             * @param {string} hex - #RRGGBB 形式のHEXカラーコード
             * @param {number} percent - 暗くする割合 (例: 20 は 20% 暗くする)
             * @returns {string} - 暗くした #RRGGBB カラーコード
             */
            function darkenHexColor(hex, percent) {
                // # を取り除く
                let r = parseInt(hex.slice(1, 3), 16);
                let g = parseInt(hex.slice(3, 5), 16);
                let b = parseInt(hex.slice(5, 7), 16);

                // 各色を暗くする (0に近づける)
                r = Math.max(0, Math.floor(r * (1 - percent / 100)));
                g = Math.max(0, Math.floor(g * (1 - percent / 100)));
                b = Math.max(0, Math.floor(b * (1 - percent / 100)));

                // HEXに戻す (各値が1桁の場合に0でパディング)
                const rHex = r.toString(16).padStart(2, '0');
                const gHex = g.toString(16).padStart(2, '0');
                const bHex = b.toString(16).padStart(2, '0');

                return `#${rHex}${gHex}${bHex}`;
            }

            // 背景色とコントロールバー、座布団の色の設定
            function setEditorBackground(color) {
                // テキストエリアの背景色
                editor.style.backgroundColor = color; 
                
                // 背景色より20%明るい色を計算
                try {
                    const lighterColor = lightenHexColor(color, 20);
                    // コントロールバーの背景色
                    controlBar.style.backgroundColor = lighterColor;
                    // エディタコンテナ（座布団）の背景色
                    editorContainer.style.backgroundColor = lighterColor;

                    // ラベルの文字色を調整 (座布団の色に応じて)
                    const labels = controlBar.querySelectorAll('label');
                    let r = parseInt(lighterColor.slice(1, 3), 16);
                    let g = parseInt(lighterColor.slice(3, 5), 16);
                    let b = parseInt(lighterColor.slice(5, 7), 16);
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;

                    labels.forEach(label => {
                        label.classList.remove('text-gray-300', 'text-gray-700'); // 既存の色を削除
                        if (brightness < 128) { // 背景が暗い
                            label.classList.add('text-gray-300'); // 明るい文字色
                        } else { // 背景が明るい
                            label.classList.add('text-gray-700'); // 暗い文字色
                        }
                    });

                } catch (e) {
                    console.error("Failed to lighten color: ", e);
                    // エラー時のフォールバック
                    controlBar.style.backgroundColor = "#ffffff"; 
                    editorContainer.style.backgroundColor = "#ffffff";
                }
            }

            // プレビュー背景色の設定 (プレビュー本体 + 座布団/コントロールバー) (修正)
            function setPreviewBackground(color) {
                // プレビューエリア本体の背景色
                preview.style.backgroundColor = color; 
                
                // (ここから変更) プレビュー背景色より「明るい」色を計算
                try {
                    const lighterColor = lightenHexColor(color, 20); // darkenHexColor から lightenHexColor に変更
                    
                    // コントロールバーの背景色
                    previewControlBar.style.backgroundColor = lighterColor; // darkerColor から lighterColor に変更
                    // プレビューコンテナ（座布団）の背景色
                    previewContainer.style.backgroundColor = lighterColor; // darkerColor から lighterColor に変更

                    // ラベルとボタンの文字色を調整 (座布団の色に応じて)
                    const labels = previewControlBar.querySelectorAll('label');
                    const controls = previewControlBar.querySelectorAll('.preview-input, .zoom-btn'); 

                    if (labels.length > 0) {
                        let r = parseInt(lighterColor.slice(1, 3), 16);
                        let g = parseInt(lighterColor.slice(3, 5), 16);
                        let b = parseInt(lighterColor.slice(5, 7), 16);
                        const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                        
                        labels.forEach(label => {
                            label.classList.remove('text-gray-600', 'text-gray-100'); // 既存の色を削除
                            if (brightness < 128) { // 背景が暗い
                                label.classList.add('text-gray-100'); // 明るい文字
                            } else { // 背景が明るい
                                label.classList.add('text-gray-600'); // 暗い文字
                            }
                        });

                        // (ここから修正) 入力要素とボタンのスタイル切替
                        controls.forEach(control => {
                            control.classList.remove('preview-input-light', 'preview-input-dark');
                            if (brightness < 128) { // 背景が暗い (座布団が暗い)
                                control.classList.add('preview-input-dark');
                            } else { // 背景が明るい (座布団が明るい)
                                control.classList.add('preview-input-light');
                            }
                        });
                    }

                } catch (e) {
                    console.error("Failed to lighten color: ", e); // (変更) darken -> lighten
                    // エラー時のフォールバック (元のbg-gray-100に近い色)
                    previewControlBar.style.backgroundColor = "#f3f4f6"; 
                    previewContainer.style.backgroundColor = "#f3f4f6";
                }
            }

            // 文字色の設定
            function setEditorTextColor(color) {
                editor.style.color = color;
            }

            // 文字サイズの設定
            function setEditorFontSize(size) {
                const safeSize = parseInt(size, 10);
                if (safeSize >= 8 && safeSize <= 64) {
                    editor.style.fontSize = `${safeSize}px`;
                } else if (!safeSize) {
                     editor.style.fontSize = '14px'; // 空の場合のデフォルト
                }
            }

            // イベントリスナーを設定
            bgPicker.addEventListener('input', (e) => {
                setEditorBackground(e.target.value);
            });

            // --- (ここから追加 バグ修正) ---
            textColorPicker.addEventListener('input', (e) => {
                // (変更) 最小化中は暗い色を、そうでなければ通常の色を設定
                if (minimizeCheckbox.checked) {
                    try {
                        editor.style.color = darkenHexColor(e.target.value, 20);
                    } catch (err) {
                        editor.style.color = e.target.value; // エラー時はフォールバック
                    }
                } else {
                    setEditorTextColor(e.target.value);
                }
            });

            fontSizeInput.addEventListener('input', (e) => {
                setEditorFontSize(e.target.value);
            });

            // プレビュー背景色用のイベントリスナー
            previewBgPicker.addEventListener('input', (e) => {
                setPreviewBackground(e.target.value);
                updatePreview(); // 背景色変更時にも枠線色を更新するために呼び出す
            });

            // (ここから追加) グリッドコントロールのイベントリスナー
            gridColsInput.addEventListener('input', updatePreview);
            gridRowsInput.addEventListener('input', updatePreview);
            gridZSelect.addEventListener('change', updatePreview); // selectはchangeイベント
            gridColorPicker.addEventListener('input', updatePreview); // (追加)

            // --- ズーム機能 ---
            // ボタンがHTMLに存在すればリスナーを設定 (非表示でも動作はする)
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    scale = parseFloat((scale + 0.1).toFixed(2));
                    applyPanZoom();
                });
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    scale = parseFloat(Math.max(0.1, scale - 0.1).toFixed(2));
                    applyPanZoom();
                });
            }

            if (zoomResetBtn) {
                zoomResetBtn.addEventListener('click', () => {
                    scale = 1.0;
                    translateX = 0;
                    translateY = 0;
                    applyPanZoom();
                });
            }

            // ホイールズーム (マウスカーソル中心)
            preview.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const newScale = parseFloat(Math.max(0.1, scale + delta).toFixed(2));
                
                const rect = preview.getBoundingClientRect();
                const mouseX = e.clientX - rect.left; // preview内でのマウスX
                const mouseY = e.clientY - rect.top; // preview内でのマウスY

                // (targetX, targetY) = ズーム中心のSVG内座標
                const targetX = (mouseX - translateX) / scale;
                const targetY = (mouseY - translateY) / scale;
                
                // 新しいscaleでの (translateX, translateY)
                translateX = mouseX - targetX * newScale;
                translateY = mouseY - targetY * newScale;
                scale = newScale;
                
                applyPanZoom();
            });

            // パン (ドラッグ)
            preview.addEventListener('mousedown', (e) => {
                // 左クリックのみ
                if (e.button !== 0) return;
                isPanning = true;
                panStartX = e.clientX - translateX;
                panStartY = e.clientY - translateY;
                preview.style.cursor = 'grabbing';
            });

            preview.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                translateX = e.clientX - panStartX;
                translateY = e.clientY - panStartY;
                applyPanZoom();
            });

            preview.addEventListener('mouseup', () => {
                isPanning = false;
                preview.style.cursor = 'default';
            });

            preview.addEventListener('mouseleave', () => {
                isPanning = false;
                preview.style.cursor = 'default';
            });

            // --- 初期スタイルの適用 ---
            // ページ読み込み時に、ピッカーの現在の値でスタイルを初期化
            setEditorBackground(bgPicker.value);
            setEditorTextColor(textColorPicker.value);
            setEditorFontSize(fontSizeInput.value);
            setPreviewBackground(previewBgPicker.value); // プレビューの初期スタイルを適用

            // --- SVGファイル読み込み機能 ---
            const loadButton = document.getElementById('load-svg-button');
            const fileInput = document.getElementById('svg-file-input');

            loadButton.addEventListener('click', () => {
                fileInput.click(); // ボタンクリックで非表示のinputをクリック
            });

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const svgContent = e.target.result;
                        editor.value = svgContent; // エディタに内容をセット
                        
                        // (追加) もし最小化チェックボックスがオンになっていたら、オフに戻す
                        if (minimizeCheckbox.checked) {
                            minimizeCheckbox.checked = false;
                            editor.readOnly = false;
                        }
                        
                        updatePreview(); // プレビューを更新
                    };
                    reader.readAsText(file);
                }
                // 同じファイルを選択しても 'change' が発火するように
                event.target.value = null; 
            });
            
            // --- SVGファイル保存機能 ---
            const saveButton = document.getElementById('save-svg-button');

            saveButton.addEventListener('click', () => {
                // エディタから現在のSVGコードを取得
                const svgContent = editor.value;
                
                // Blobオブジェクトを作成
                const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
                
                // ダウンロード用のURLを生成
                const url = URL.createObjectURL(blob);
                
                // 非表示のアンカーリンクを作成してクリックイベントを発火させる
                const a = document.createElement('a');
                a.href = url;
                a.download = 'edited.svg'; // デフォルトのファイル名
                document.body.appendChild(a); // DOMに追加 (Firefoxで必要)
                a.click();
                
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
            // --- 最小化機能 ---
            minimizeCheckbox.addEventListener('change', () => {
                if (minimizeCheckbox.checked) {
                    // 1. 現在の内容をバックアップ
                    originalSvgContent = editor.value;
                    
                    // 2. 最小化してエディタにセット
                    editor.value = minifySvg(originalSvgContent);
                    
                    // 3. 編集不可に
                    editor.readOnly = true;
                    
                    // 4. 文字色を暗くする
                    try {
                        editor.style.color = darkenHexColor(textColorPicker.value, 20);
                    } catch (e) {
                        // darkenHexColor が失敗した場合 (不正な色など) でも、元の色を設定
                        editor.style.color = textColorPicker.value;
                        console.error("Failed to darken color on minimize:", e);
                    }

                    // 5. プレビューを更新 (最小化してもプレビューは変わらないはずだが念のため)
                    updatePreview();
                } else {
                    // 1. バックアップから元の内容を復元
                    editor.value = originalSvgContent;
                    // 2. 編集可能に
                    editor.readOnly = false;
                    // 3. 文字色を元に戻す
                    setEditorTextColor(textColorPicker.value);

                    updatePreview();
                }
            });

        });
    </script>

</body>
</html>

