<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal SVG Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            font-family: 'Inter', sans-serif;
            overflow: hidden; 
        }
        textarea {
            font-family: monospace;
            outline: none;
            resize: none;
        }
        /* カラーピッカーのサイズを調整 */
        input[type="color"] {
            width: 24px;
            height: 24px;
            padding: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        /* カラーピッカーのブラウザデフォルトスタイルを隠す (Chrome/Safari) */
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }
        /* カラーピッカーのブラウザデフォルトスタイルを隠す (Firefox) */
        input[type="color"]::-moz-focus-inner {
            border: 0;
            padding: 0;
        }
        input[type="color"]::-moz-color-swatch {
            border: none;
            border-radius: 4px;
        }
        /* プレビューエリアを相対配置（グリッドSVGを重ねるため） */
        #preview {
            position: relative;
            overflow: hidden;
        }
        /* プレビューコントロールバーの入力要素スタイル */
        .preview-input {
            padding: 0.375rem 0.5rem; /* p-1.5 と p-2 の中間 */
            border-radius: 0.375rem; /* rounded-md */
            border: none;
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
            outline: none;
        }
        .preview-input:focus {
            box-shadow: 0 0 0 2px var(--tw-ring-color, #3B82F6); /* focus:ring-2 focus:ring-blue-500 */
        }
        /* 明るい背景用の入力スタイル */
        .preview-input-light {
            background-color: #d8d8d8;
            color: #282828; 
        }
        /* 暗い背景用の入力スタイル */
        .preview-input-dark {
            background-color: #282828;
            color: #d8d8d8;
        }
        .github-icon-link {position: fixed; bottom: 4px; right: 4px; z-index: 999;}
        .github-icon-link img {width: 32px; height: 32px;}
        .github-icon-link:hover img {transform: scale(1.1);}

        /* リサイズバー */
        #resizer {
            background-color: #000000;
            flex-shrink: 0;
            z-index: 50; /* 他要素より手前に */
        }

        /* モバイル (デフォルト: 上下分割) */
        #resizer {
            width: 100%;
            height: 2px;
            cursor: row-resize;
        }
        
        /* デスクトップ (md以上: 左右分割) */
        @media (min-width: 768px) {
            #resizer {
                width: 2px;
                height: auto; /* flex-row の中のため auto で親の高さに */
                cursor: col-resize;
            }
        }

        /* リサイズ中のテキスト選択を無効化 */
        .resizing {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

    </style>
</head>
<body class="bg-black flex flex-col">

    <div class="flex flex-col md:flex-row flex-grow h-full">
        
        <!-- 左側: プレビューエリア -->
        <div id="preview-container" class="shadow-lg flex flex-col transition-colors duration-150 flex-1 overflow-hidden" style="flex-basis: 50%; min-height: 200px; min-width: 200px;">
            <div class="flex flex-col h-full">
                <!-- プレビュー コントロールバー -->
                <div id="preview-control-bar" class="flex items-center justify-start flex-wrap gap-3 gap-y-2 p-2 rounded-md transition-colors duration-150">
                    <!-- プレビュー背景色 -->
                    <div class="flex items-center space-x-2">
                        <label for="preview-bg-color-picker" id="preview-bg-label" class="text-gray-600 text-sm font-medium">背景</label>
                        <input type="color" id="preview-bg-color-picker" title="プレビュー背景色を選択" value="#111827">
                    </div>
                    <!-- 補助線カラーピッカー -->
                    <div class="flex items-center space-x-2">
                        <label for="grid-color-picker" id="grid-color-label" class="text-gray-600 text-sm font-medium">線色</label>
                        <input type="color" id="grid-color-picker" title="補助線と枠線の色を選択" value="#eeeeee">
                    </div>
                    <!-- 補助線コントロール -->
                    <div class="flex items-center space-x-2">
                        <label for="grid-cols-input" class="text-gray-600 text-sm font-medium">横分割</label>
                        <input type="number" id="grid-cols-input" min="1" max="32" value="2"
                               class="w-14 preview-input preview-input-light"
                               title="横の分割数 (1-32)">
                    </div>
                    <div class="flex items-center space-x-2">
                        <label for="grid-rows-input" class="text-gray-600 text-sm font-medium">縦分割</label>
                        <input type="number" id="grid-rows-input" min="1" max="32" value="2"
                               class="w-14 preview-input preview-input-light"
                               title="縦の分割数 (1-32)">
                    </div>
                    <div class="flex items-center space-x-2">
                        <label for="grid-z-select" class="text-gray-600 text-sm font-medium">線</label>
                        <select id="grid-z-select" class="preview-input preview-input-light" title="補助線の前後">
                            <option value="back">背面</option>
                            <option value="front">前面</option>
                        </select>
                    </div>
                    <!-- ズームコントロール (非表示) -->
                    <div class="flex items-center space-x-2 hidden">
                        <label id="preview-zoom-label" class="text-gray-600 text-sm font-medium">ズーム</label>
                        <button id="zoom-out-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-lg font-bold preview-input preview-input-light" title="縮小">-</button>
                        <button id="zoom-reset-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-sm preview-input preview-input-light" title="リセット">100%</button>
                        <button id="zoom-in-btn" type="button" class="zoom-btn px-2 py-0.5 rounded-md text-lg font-bold preview-input preview-input-light" title="拡大">+</button>
                    </div>
                </div>
                
                <!-- プレビュー本体 flex-grow を追加し、高さを確保 -->
                <div id="preview" class="w-full h-full p-2 transition-colors duration-150 flex-grow">
                    <!-- パン・ズーム用のコンテナ (transform-origin: 0 0) -->
                    <div id="svg-container" style="width: 100%; height: 100%; transform-origin: 0 0;">
                        <!-- ユーザーSVG専用のラッパーを追加 -->
                        <div id="user-svg-wrapper" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                            <!-- ここにSVGがレンダリングされます -->
                        </div>
                        <!-- gridSvg は JS によってここに追加されます -->
                    </div>
                </div>
            </div>
        </div>

        <!-- リサイズバー -->
        <div id="resizer"></div>

        <!-- 右側: エディタエリア -->
        <div id="editor-container" class="shadow-lg flex flex-col transition-colors duration-150 flex-1 overflow-hidden" style="flex-basis: 50%; min-height: 200px; min-width: 200px;">
            <div class="flex flex-col h-full">
                <!-- コントロールバー -->
                <div id="control-bar" class="flex items-center justify-start flex-wrap gap-3 gap-y-2 p-2 rounded-md transition-colors duration-150">
                    
                    <!-- 背景色 -->
                    <div class="flex items-center space-x-2">
                        <label for="bg-color-picker" class="text-gray-300 text-sm font-medium">背景</label>
                        <input type="color" id="bg-color-picker" title="背景色を選択" value="#111827">
                    </div>
                    <!-- 文字色 -->
                    <div class="flex items-center space-x-2">
                        <label for="text-color-picker" class="text-gray-300 text-sm font-medium">文字</label>
                        <input type="color" id="text-color-picker" title="文字色を選択" value="#eeeeee">
                    </div>
                    <!-- 文字サイズ -->
                    <div class="flex items-center space-x-2">
                        <label for="font-size-input" class="text-gray-300 text-sm font-medium">サイズ</label>
                        <input type="number" id="font-size-input" min="8" max="64" value="14"
                               class="w-14 preview-input preview-input-light"
                               title="フォントサイズ (8-64)">
                    </div>
                    <!-- SVG読み込みボタン -->
                    <div class="flex items-center">
                        <input type="file" id="svg-file-input" accept="image/svg+xml,.svg" class="hidden">
                        <button id="load-svg-button" type="button"
                                class="px-3 py-1.5 bg-blue-600 text-white text-sm font-medium rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition-colors">
                            SVGを開く
                        </button>
                    </div>
                    <!-- SVG保存ボタン -->
                    <div class="flex items-center">
                        <button id="save-svg-button" type="button"
                                class="px-3 py-1.5 bg-green-600 text-white text-sm font-medium rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 focus:ring-offset-gray-800 transition-colors">
                            SVGを保存
                        </button>
                    </div>
                    <!-- 小数点桁数入力 -->
                    <div class="flex items-center space-x-2">
                        <label for="decimal-places-input" class="text-gray-300 text-sm font-medium">小数点</label>
                        <input type="number" id="decimal-places-input" min="-1" max="16" value="2"
                               class="w-14 preview-input preview-input-light" title="最小化時の小数点以下の桁数 (-1で無効, 0-16)">
                    </div>
                    <!-- 最小化チェックボックス -->
                    <div class="flex items-center space-x-2">
                        <label for="minimize-svg-checkbox" class="text-gray-300 text-sm font-medium">最小化</label>
                        <input type="checkbox" id="minimize-svg-checkbox" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600 ring-offset-gray-800 focus:ring-2"
                                title="破壊的な場合あり">
                    </div>
                </div>
                
                <!-- テキストエリア -->
                <textarea id="svg-editor" 
                          class="w-full h-full p-4 leading-relaxed flex-grow" 
                          spellcheck="false">
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">

<defs>
	<linearGradient id="myGradient" x1="0%" y1="0%" x2="100%" y2="0%">
		<stop offset="0%" stop-color="#ff0000"/> 
		<stop offset="100%" stop-color="#ffff00"/> 
	</linearGradient>

	<pattern id="myPattern" width="20" height="20" patternUnits="userSpaceOnUse">
		<circle cx="10" cy="10" r="5" fill="url(#myGradient)"/>
	</pattern>  
</defs>

<polygon points="50.12345,5.6789 61,40 98,40 68,62 79,96 50,75 21,96 32,62 2,40 39,40"
	fill="url(#myPattern)" stroke="#ff0" stroke-width="1.0" />

</svg></textarea>
            </div>
        </div>
    </div>

    <a href="https://github.com/black-sesame-ice-cream/minimal-svg-editor" target="_blank" rel="noopener noreferrer" class="github-icon-link" title="View on GitHub">
        <img src="/images/github-icon.svg" alt="GitHub" />
    </a>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Constants ---
            const MIN_PANEL_SIZE = 200;
            const GRID_MAX_DIVISIONS = 32;
            const FONT_MIN_SIZE = 8;
            const FONT_MAX_SIZE = 64;
            const FONT_DEFAULT_SIZE = 14;
            const PAN_ZOOM_STEP = 0.1;
            const PAN_ZOOM_MIN = 0.1;

            // --- State Variables ---
            let scale = 1.0;
            let translateX = 0;
            let translateY = 0;
            let isPanning = false;
            let panStartX = 0;
            let panStartY = 0;
            let originalSvgContent = ''; // 最小化前のSVGを保持
            let isResizing = false;
            let lastSvgAttrs = null; // (変更) 最後に解析したSVG属性を保持

            // --- DOM Elements ---
            const editor = document.getElementById('svg-editor');
            const preview = document.getElementById('preview');
            const svgContainer = document.getElementById('svg-container');
            const userSvgWrapper = document.getElementById('user-svg-wrapper'); 
            const resizer = document.getElementById('resizer');
            
            // Editor Controls
            const editorContainer = document.getElementById('editor-container');
            const controlBar = document.getElementById('control-bar');
            const bgPicker = document.getElementById('bg-color-picker');
            const textColorPicker = document.getElementById('text-color-picker');
            const fontSizeInput = document.getElementById('font-size-input');
            const loadButton = document.getElementById('load-svg-button');
            const fileInput = document.getElementById('svg-file-input');
            const saveButton = document.getElementById('save-svg-button');
            const minimizeCheckbox = document.getElementById('minimize-svg-checkbox');
            const decimalPlacesInput = document.getElementById('decimal-places-input'); 

            // Preview Controls
            const previewContainer = document.getElementById('preview-container');
            const previewControlBar = document.getElementById('preview-control-bar');
            const previewBgPicker = document.getElementById('preview-bg-color-picker');
            const gridColsInput = document.getElementById('grid-cols-input');
            const gridRowsInput = document.getElementById('grid-rows-input');
            const gridZSelect = document.getElementById('grid-z-select');
            const gridColorPicker = document.getElementById('grid-color-picker');
            
            // 補助線表示用のSVG要素を作成
            const gridSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            gridSvg.id = 'preview-grid-svg';
            Object.assign(gridSvg.style, {
                position: 'absolute',
                top: '0',
                left: '0',
                width: '100%',
                height: '100%',
                pointerEvents: 'none' // グリッドが操作を妨害しないように
            });
            svgContainer.appendChild(gridSvg); 

            // --- Utility Functions ---

            /**
             * SVG文字列を最小化します。
             * (変更) 以下の順序で実行
             * 1. 保護なしで安全なコメント・空白を削除 (HTML, CSS, JSコメント対応)
             * 2. style/script/特定属性を保護
             * 3. 小数点を丸める
             * 4. 保護を解除
             */
            function minifySvg(svgString, digits) {
                if (typeof svgString !== 'string') return '';
                let minified = svgString;

                // --- ステップ1: 保護なしで安全な削除 ---

                // 1a. HTMLコメント削除
                minified = minified.replace(/<!--[\s\S]*?-->/g, '');
                
                // 1b. CSS/JS ブロックコメント削除 (/* ... */)
                minified = minified.replace(/\/\*[\s\S]*?\*\//g, '');

                // 1c. JS 行コメント削除 (// ...)
                // (注意: SVG属性値やテキストノード内の '//' も削除される可能性あり)
                minified = minified.replace(/\/\/[^\r\n]*/g, '');

                // 1d. (変更) すべての改行を削除
                minified = minified.replace(/[\r\n]+/g, ''); // 改行を完全に削除

                // 1e. (変更) タグ間の空白を削除 (改行はステップ1dで削除済み)
                minified = minified.replace(/>\s+</g, '><');

                // 1f. (新規) 2個以上続くスペースを1個にする
                // (タブはスペースに変換してから圧縮)
                minified = minified.replace(/\t/g, ' '); // タブをスペースに
                minified = minified.replace(/[ ]{2,}/g, ' '); // 2個以上のスペースを1個に

                // --- ステップ2: 保護 ---
                
                const protectedParts = [];
                const placeholder = (index) => `__PROTECTED_${index}__`;

                // 保護関数
                const protect = (regex) => {
                    minified = minified.replace(regex, (match) => {
                        protectedParts.push(match);
                        return placeholder(protectedParts.length - 1);
                    });
                };

                // 2a. <style> と <script> タグ
                // (ステップ1で中のコメントが消えている可能性あり)
                protect(/<style[\s\S]*?<\/style>/gi);
                protect(/<script[\s\S]*?<\/script>/gi);
                
                // 2b. 破壊されると困る属性 (id, href, style, values, keyTimes)
                // ダブルクォートの場合
                protect(/\s+(id|href|style|values|keyTimes)\s*=\s*"[^"]*"/gi);
                // シングルクォートの場合
                protect(/\s+(id|href|style|values|keyTimes)\s*=\s*'[^']*'/gi);

                // --- ステップ3: 小数点丸め (保護後) ---
                
                const digitsInt = parseInt(digits, 10);
                if (!isNaN(digitsInt) && digitsInt >= 0) {
                    try {
                        // 正規表現: オプションのマイナス記号 + 数字 + ドット + 数字
                        // (変更) (?![eE]) を追加し、科学技術計算表記 (e.g., 1.23e-5) を除外
                        minified = minified.replace(/([-+]?\d+\.\d+)(?![eE])/g, (match) => {
                            const num = parseFloat(match);
                            if (isNaN(num)) return match; // パース失敗時はそのまま
                            return String(parseFloat(num.toFixed(digitsInt)));
                        });
                    } catch (e) {
                        console.error("Failed to round decimals during minify:", e);
                        // エラーが発生した場合は、このステップをスキップして続行
                    }
                }

                // --- ステップ4: 復元 ---
                
                // プレースホルダーを元の保護した内容に戻す
                for (let i = protectedParts.length - 1; i >= 0; i--) {
                    // $& は マッチした文字列全体 を参照する
                    minified = minified.replace(placeholder(i), () => protectedParts[i]);
                }

                return minified.trim();
            }


            /**
             * HEXコードを明るくする関数
             */
            function lightenHexColor(hex, percent) {
                let r = parseInt(hex.slice(1, 3), 16);
                let g = parseInt(hex.slice(3, 5), 16);
                let b = parseInt(hex.slice(5, 7), 16);
                r = Math.min(255, Math.floor(r + (255 - r) * (percent / 100)));
                g = Math.min(255, Math.floor(g + (255 - g) * (percent / 100)));
                b = Math.min(255, Math.floor(b + (255 - b) * (percent / 100)));
                const rHex = r.toString(16).padStart(2, '0');
                const gHex = g.toString(16).padStart(2, '0');
                const bHex = b.toString(16).padStart(2, '0');
                return `#${rHex}${gHex}${bHex}`;
            }

            /**
             * HEXカラーコードを指定された不透明度（アルファ）のRGBA文字列に変換します。
             */
            function hexToRgba(hex, alpha) {
                let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);

                let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                if (!result) return null; // 不正なHEXコード

                const r = parseInt(result[1], 16);
                const g = parseInt(result[2], 16);
                const b = parseInt(result[3], 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            // --- Theme Functions ---

            /**
             * パネル（エディタまたはプレビュー）のテーマ（背景色、文字色、入力欄スタイル）を設定します。
             * @param {HTMLElement} container - 全体コンテナ (e.g., editorContainer)
             * @param {HTMLElement} controlBar - コントロールバー (e.g., controlBar)
             * @param {string} color - ベースとなるHEXカラーコード
             * @param {string} inputSelector - スタイルを適用する入力欄のCSSセレクタ
             * @param {string} labelSelector - スタイルを適用するラベルのCSSセレクタ
             * @param {string} baseElementStyleProp - ベース要素に適用するスタイルプロパティ ('backgroundColor' or 'color')
             * @param {HTMLElement} [baseElement=null] - ベースとなる要素 (e.g., editor, preview)
             */
            function setPanelTheme(container, controlBar, color, inputSelector, labelSelector, baseElementStyleProp, baseElement = null) {
                if (baseElement) {
                    baseElement.style[baseElementStyleProp] = color;
                }

                try {
                    const lighterColor = lightenHexColor(color, 20);
                    controlBar.style.backgroundColor = lighterColor;
                    container.style.backgroundColor = lighterColor;

                    const labels = controlBar.querySelectorAll(labelSelector);
                    const controls = controlBar.querySelectorAll(inputSelector); 

                    let r = parseInt(lighterColor.slice(1, 3), 16);
                    let g = parseInt(lighterColor.slice(3, 5), 16);
                    let b = parseInt(lighterColor.slice(5, 7), 16);
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;

                    const [labelLight, labelDark] = (labelSelector === '#preview-control-bar label') 
                        ? ['text-gray-700', 'text-gray-100'] 
                        : ['text-gray-700', 'text-gray-300'];

                    labels.forEach(label => {
                        label.classList.remove(labelLight, labelDark); 
                        label.classList.add(brightness < 128 ? labelDark : labelLight); 
                    });

                    controls.forEach(control => {
                        control.classList.remove('preview-input-light', 'preview-input-dark');
                        control.classList.add(brightness < 128 ? 'preview-input-dark' : 'preview-input-light');
                    });

                } catch (e) {
                    console.error("Failed to apply theme color: ", e);
                    controlBar.style.backgroundColor = "#f3f4f6"; 
                    container.style.backgroundColor = "#f3f4f6";
                }
            }

            function setEditorBackground(color) {
                setPanelTheme(editorContainer, controlBar, color, 
                    '#control-bar .preview-input', '#control-bar label', 
                    'backgroundColor', editor);
            }

            function setPreviewBackground(color) {
                setPanelTheme(previewContainer, previewControlBar, color, 
                    '#preview-control-bar .preview-input, #preview-control-bar .zoom-btn', '#preview-control-bar label', 
                    'backgroundColor', preview);
            }

            function setEditorTextColor(color) {
                editor.style.color = color;
            }

            // (追加 2) 状態に応じてエディタ文字色を更新する共通関数
            /**
             * 現在の状態 (最小化チェック) に応じてエディタの文字色を更新します。
             */
            function updateEditorTextColorBasedOnState() {
                const color = textColorPicker.value;
                if (minimizeCheckbox.checked) {
                    try {
                        // 最小化中は半透明にする
                        editor.style.color = hexToRgba(color, 0.4); 
                    } catch (err) {
                        console.error("Failed to apply rgba color on minimize:", err);
                        editor.style.color = color; // フォールバック
                    }
                } else {
                    // 通常時はそのままの色
                    setEditorTextColor(color);
                }
            }


            function setEditorFontSize(size) {
                const safeSize = parseInt(size, 10);
                if (safeSize >= FONT_MIN_SIZE && safeSize <= FONT_MAX_SIZE) {
                    editor.style.fontSize = `${safeSize}px`;
                } else if (!safeSize) {
                     editor.style.fontSize = `${FONT_DEFAULT_SIZE}px`; // 空の場合のデフォルト
                }
            }

            // --- Preview Rendering ---

            /**
             * SVGコードを解析し、viewBoxやpreserveAspectRatioなどの属性情報を抽出・計算します。
             */
            function parseSvgAttributes(svgCode) {
                const attrs = {
                    svgTagMatch: null,
                    viewBoxValue: null,
                    preserveAspectRatioValue: null,
                    vbParts: null,
                    newViewBoxValue: null
                };

                attrs.svgTagMatch = svgCode.match(/<svg([^>]*)>/i);
                if (!attrs.svgTagMatch) return attrs;

                const svgTagAttributes = attrs.svgTagMatch[1];
                const viewBoxMatch = svgTagAttributes.match(/viewBox="([^"]+)"/i);
                if (viewBoxMatch) {
                    attrs.viewBoxValue = viewBoxMatch[1];
                }

                const preserveAspectRatioMatch = svgTagAttributes.match(/preserveAspectRatio="([^"]+)"/i);
                if (preserveAspectRatioMatch) {
                    attrs.preserveAspectRatioValue = preserveAspectRatioMatch[1];
                }

                // viewBoxがない場合、width/heightから生成を試みる
                if (!attrs.viewBoxValue) {
                    const widthMatch = svgTagAttributes.match(/width="([^"]+)"/i);
                    const heightMatch = svgTagAttributes.match(/height="([^"]+)"/i);
                    let vbWidth = null;
                    let vbHeight = null;

                    if (widthMatch && /^[0-9.]+p?x?$/.test(widthMatch[1])) {
                        vbWidth = parseFloat(widthMatch[1]);
                    }
                    if (heightMatch && /^[0-9.]+p?x?$/.test(heightMatch[1])) {
                        vbHeight = parseFloat(heightMatch[1]);
                    }
                    
                    if (vbWidth && vbHeight) {
                        attrs.viewBoxValue = `0 0 ${vbWidth} ${vbHeight}`;
                    }
                }
                
                // viewBoxをグリッド表示用に拡張
                if (attrs.viewBoxValue) {
                    attrs.vbParts = attrs.viewBoxValue.split(' ').map(Number);
                    if (attrs.vbParts.length === 4 && !isNaN(attrs.vbParts[2]) && !isNaN(attrs.vbParts[3])) {
                        const [vbX, vbY, vbWidth, vbHeight] = attrs.vbParts;
                        const newWidth = vbWidth * 2; 
                        const newHeight = vbHeight * 2;
                        const newX = vbX - (vbWidth * 0.5); 
                        const newY = vbY - (vbHeight * 0.5); 
                        attrs.newViewBoxValue = `${newX} ${newY} ${newWidth} ${newHeight}`;
                    } else {
                        attrs.viewBoxValue = null; 
                        attrs.vbParts = null;
                    }
                }
                
                return attrs;
            }

            /**
             * 解析した属性に基づいて、SVGコードの<svg>タグを更新します。
             */
            function updateSvgAttributes(svgCode, attrs) {
                if (!attrs.svgTagMatch) return svgCode;

                let newAttributes = attrs.svgTagMatch[1];
                
                // width/height属性を削除
                newAttributes = newAttributes.replace(/width="[^"]+"/i, '');
                newAttributes = newAttributes.replace(/height="[^"]+"/i, '');

                // 拡張viewBoxを適用
                if (attrs.newViewBoxValue) { 
                    if (attrs.svgTagMatch[1].match(/viewBox="[^"]+"/i)) { 
                        newAttributes = newAttributes.replace(/viewBox="[^"]+"/i, `viewBox="${attrs.newViewBoxValue}"`);
                    } else { 
                        newAttributes += ` viewBox="${attrs.newViewBoxValue}"`;
                    }
                } else if (attrs.viewBoxValue) {
                     if (attrs.svgTagMatch[1].match(/viewBox="[^"]+"/i)) {
                        newAttributes = newAttributes.replace(/viewBox="[^"]+"/i, `viewBox="${attrs.viewBoxValue}"`);
                    } else {
                        newAttributes += ` viewBox="${attrs.viewBoxValue}"`;
                    }
                }
                
                // viewBoxがあり、preserveAspectRatioがない場合、デフォルトを追加
                if (attrs.viewBoxValue && !attrs.preserveAspectRatioValue) { 
                    attrs.preserveAspectRatioValue = 'xMidYMid meet'; 
                    newAttributes += ` preserveAspectRatio="${attrs.preserveAspectRatioValue}"`;
                }
                
                return svgCode.replace(/<svg[^>]*>/i, `<svg${newAttributes}>`);
            }

            /**
             * プレビューに補助線グリッドを描画します。
             */
            function drawGrid(svgElement, attrs, currentScale = 1.0) { // (変更) currentScale を引数に追加
                if (!svgElement || !attrs) { // (変更) attrs もチェック
                    gridSvg.innerHTML = '';
                    return;
                }

                Object.assign(svgElement.style, {
                    width: '100%',
                    height: '100%',
                });
                gridSvg.style.width = '100%';
                gridSvg.style.height = '100%';

                try {
                    const gridColor = gridColorPicker.value; 
                    
                    if (!attrs.viewBoxValue || !attrs.vbParts || !attrs.newViewBoxValue) { 
                        gridSvg.innerHTML = ''; 
                        return;
                    }

                    const [vbX, vbY, vbWidth, vbHeight] = attrs.vbParts;
                    // (変更) newViewBoxValue をパースして newWidth/newHeight を取得
                    const [newX, newY, newWidth, newHeight] = attrs.newViewBoxValue.split(' ').map(Number);


                    gridSvg.setAttribute('viewBox', attrs.newViewBoxValue);
                    
                    if (attrs.preserveAspectRatioValue) {
                        gridSvg.setAttribute('preserveAspectRatio', attrs.preserveAspectRatioValue);
                        svgElement.setAttribute('preserveAspectRatio', attrs.preserveAspectRatioValue); 
                    } else {
                        gridSvg.removeAttribute('preserveAspectRatio'); 
                        svgElement.removeAttribute('preserveAspectRatio');
                    }

                    const cols = Math.max(1, Math.min(GRID_MAX_DIVISIONS, parseInt(gridColsInput.value, 10) || 1));
                    const rows = Math.max(1, Math.min(GRID_MAX_DIVISIONS, parseInt(gridRowsInput.value, 10) || 1));
                    const zIndexOption = gridZSelect.value;
                    
                    // (新規) コンテナサイズ取得
                    const containerWidth = preview.clientWidth;
                    const containerHeight = preview.clientHeight;

                    // (新規) ゼロ除算防止
                    if (containerWidth <= 0 || containerHeight <= 0 || newWidth <= 0 || newHeight <= 0) {
                        gridSvg.innerHTML = '';
                        return;
                    }

                    // (新規) 1ピクセルがviewBox単位でいくつに相当するかを計算
                    const containerAspect = containerWidth / containerHeight;
                    const viewBoxAspect = newWidth / newHeight; // (変更) newWidth/newHeight を使用

                    let unitsPerPixel;
                    // (変更) `preserveAspectRatio` の "meet" ロジックに基づいて計算
                    if (viewBoxAspect > containerAspect) {
                        // ViewBox is wider than container, so width is the limiting dimension
                        unitsPerPixel = newWidth / (containerWidth * currentScale);
                    } else {
                        // ViewBox is taller than container (or same aspect), so height is the limiting dimension
                        unitsPerPixel = newHeight / (containerHeight * currentScale);
                    }

                    // (新規) 画面ピクセルベースでサイズを定義
                    const desiredStrokeWidthPx = 1;
                    const desiredFontSizePx = 10;
                    const desiredGapPx = 2; // 線とテキストの隙間

                    // (新規) viewBox単位に変換
                    const dynamicStrokeWidth = desiredStrokeWidthPx * unitsPerPixel;
                    const dynamicFontSize = desiredFontSizePx * unitsPerPixel;
                    const textOffset = desiredGapPx * unitsPerPixel; // 隙間

                    let pathD = '';
                    let textElements = ''; // (変更) テキスト要素用の文字列を初期化
                    
                    // (削除) 以前の baseFontSize, baseStrokeWidth の計算を削除

                    if (cols > 1) {
                        for (let i = 1; i < cols; i++) {
                            const x = vbX + (vbWidth / cols) * i;
                            pathD += `M ${x} ${vbY} V ${vbY + vbHeight} `; 
                            
                            // (変更) dynamicFontSize, textOffset を使用し、dominant-baseline を調整
                            const yPos = vbY - textOffset; // 線の上側にオフセット
                            textElements += `<text x="${x}" y="${yPos}" 
                                                  font-size="${dynamicFontSize}" fill="${gridColor}" 
                                                  text-anchor="middle" dominant-baseline="text-after-edge">
                                                ${x.toFixed(0)}
                                            </text>`;
                        }
                    }
                    if (rows > 1) {
                        for (let j = 1; j < rows; j++) {
                            const y = vbY + (vbHeight / rows) * j;
                            pathD += `M ${vbX} ${y} H ${vbX + vbWidth} `; 

                            // (変更) dynamicFontSize, textOffset を使用
                            const xPos = vbX - textOffset; // 線の左側にオフセット
                            textElements += `<text x="${xPos}" y="${y}" 
                                                  font-size="${dynamicFontSize}" fill="${gridColor}" 
                                                  text-anchor="end" dominant-baseline="middle">
                                                ${y.toFixed(0)}
                                            </text>`;
                        }
                    }
                    
                    // (変更) strokeWidth を dynamicStrokeWidth に
                    const borderPathD = `M ${vbX} ${vbY} H ${vbX + vbWidth} V ${vbY + vbHeight} H ${vbX} Z`;

                    // (変更) innerHTMLに <path> と <text> を <g> で囲んで設定 (path から vector-effect を削除)
                    gridSvg.innerHTML = `<g>
                                            <path d="${borderPathD} ${pathD}" 
                                                  stroke="${gridColor}" stroke-width="${dynamicStrokeWidth}" 
                                                  fill="none" />
                                            ${textElements}
                                         </g>`;


                    if (zIndexOption === 'back') {
                        userSvgWrapper.style.zIndex = '10';
                        gridSvg.style.zIndex = '0';
                    } else {
                        userSvgWrapper.style.zIndex = '0';
                        gridSvg.style.zIndex = '10';
                    }

                } catch (e) {
                    console.error("Failed to apply viewBox border or grid: ", e);
                    gridSvg.innerHTML = ''; 
                }
            }
            
            /**
             * SVGを解析、更新、描画するメイン関数
             */
            function renderPreview() {
                const svgCodeRaw = editor.value;
                lastSvgAttrs = parseSvgAttributes(svgCodeRaw); // (変更) 属性をグローバルに保存
                const svgCodeUpdated = updateSvgAttributes(svgCodeRaw, lastSvgAttrs);

                userSvgWrapper.innerHTML = svgCodeUpdated; 
                const svgElement = userSvgWrapper.querySelector('svg'); 
                drawGrid(svgElement, lastSvgAttrs, scale); // (変更) scale を渡す
            }

            // --- Pan & Zoom ---

            function applyPanZoom() {
                svgContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }

            function initPanZoom() {
                // ホイールズーム (マウスカーソル中心)
                preview.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -PAN_ZOOM_STEP : PAN_ZOOM_STEP;
                    const newScale = parseFloat(Math.max(PAN_ZOOM_MIN, scale + delta).toFixed(2));
                    
                    const rect = preview.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left; 
                    const mouseY = e.clientY - rect.top; 

                    const targetX = (mouseX - translateX) / scale;
                    const targetY = (mouseY - translateY) / scale;
                    
                    translateX = mouseX - targetX * newScale;
                    translateY = mouseY - targetY * newScale;
                    scale = newScale;
                    
                    applyPanZoom();

                    // (新規) ズーム後にグリッドを再描画
                    const svgElement = userSvgWrapper.querySelector('svg');
                    drawGrid(svgElement, lastSvgAttrs, scale);
                });

                // パン (ドラッグ)
                preview.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    isPanning = true;
                    panStartX = e.clientX - translateX;
                    panStartY = e.clientY - translateY;
                    preview.style.cursor = 'grabbing';
                });
                preview.addEventListener('mousemove', (e) => {
                    if (!isPanning) return;
                    translateX = e.clientX - panStartX;
                    translateY = e.clientY - panStartY;
                    applyPanZoom();
                    // (注) パンではスケールは変わらないのでグリッド再描画は不要
                });
                preview.addEventListener('mouseup', () => {
                    isPanning = false;
                    preview.style.cursor = 'default';
                });
                preview.addEventListener('mouseleave', () => {
                    isPanning = false;
                    preview.style.cursor = 'default';
                });
            }

            // --- Snippets ---
            const snippets = {
                '<svg': '<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">\n\t\n</svg>',
                '<r': '<rect x="" y="" width="" height="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<c': '<circle cx="" cy="" r="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<e': '<ellipse cx="" cy="" rx="" ry="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<l': '<line x1="" y1="" x2="" y2="" stroke="#000" stroke-width=""/>',
                '<pl': '<polyline points="" fill="none" stroke="#000" stroke-width=""/>',
                '<pg': '<polygon points="" fill="#fff" stroke="#000" stroke-width=""/>',
                '<p': '<path d="" fill="none" stroke="#000" stroke-width=""/>',
                '<t': '<text x="" y="" fill="#000" font-size="">text</text>',
                '<g': '<g>\n\t\n</g>',
                '<defs': '<defs>\n\t\n</defs>',
                '<lg': '<linearGradient id="" x1="0%" y1="0%" x2="100%" y2="0%">\n\t<stop offset="0%" stop-color="" />\n\t<stop offset="100%" stop-color="" />\n</linearGradient>',
                '<rg': '<radialGradient id="" cx="50%" cy="50%" r="50%">\n\t<stop offset="0%" stop-color="" />\n\t<stop offset="100%" stop-color="" />\n</radialGradient>',
                '<ptn': '<pattern id="" width="" height="" patternUnits="userSpaceOnUse">\n\t\n</pattern>',
                '<use': '<use href="#id" x="" y=""/>'
            };

            function initSnippets() {
                editor.addEventListener('keydown', (e) => {
                    if (editor.readOnly) return;

                    if (e.key === 'Tab' || e.key === 'Enter') {
                        const start = editor.selectionStart;
                        const textBefore = editor.value.substring(0, start);
                        let triggerKey = Object.keys(snippets).find(key => textBefore.endsWith(key));

                        if (triggerKey) {
                            e.preventDefault(); 
                            const snippetValue = snippets[triggerKey];
                            const newTextBefore = textBefore.substring(0, textBefore.length - triggerKey.length);
                            const textAfter = editor.value.substring(start);
                            
                            editor.value = newTextBefore + snippetValue + textAfter;

                            const firstQuoteIndex = snippetValue.indexOf('""');
                            let newCursorPos = (firstQuoteIndex !== -1)
                                ? newTextBefore.length + firstQuoteIndex + 1
                                : newTextBefore.length + snippetValue.length;
                                
                            editor.selectionStart = editor.selectionEnd = newCursorPos;
                            renderPreview(); 
                        } else if (e.key === 'Tab') {
                            e.preventDefault();
                            const end = editor.selectionEnd;
                            editor.value = editor.value.substring(0, start) + '\t' + editor.value.substring(end);
                            editor.selectionStart = editor.selectionEnd = start + 1;
                            renderPreview();
                        }
                    }
                });
            }

            // --- Event Listeners Initialization ---

            function initEditorControls() {
                editor.addEventListener('input', () => {
                    if (editor.readOnly) return;
                    renderPreview();
                });

                bgPicker.addEventListener('input', (e) => setEditorBackground(e.target.value));

                textColorPicker.addEventListener('input', updateEditorTextColorBasedOnState);

                fontSizeInput.addEventListener('input', (e) => setEditorFontSize(e.target.value));

                minimizeCheckbox.addEventListener('change', () => {
                    if (minimizeCheckbox.checked) {
                        originalSvgContent = editor.value;
                        // (変更) decimalPlacesInput.value から桁数を取得
                        const digits = decimalPlacesInput.value; 
                        editor.value = minifySvg(originalSvgContent, digits); // (変更) 桁数を渡す
                        editor.readOnly = true;
                    } else {
                        editor.value = originalSvgContent;
                        editor.readOnly = false;
                    }
                    // 状態変更後に文字色を更新
                    updateEditorTextColorBasedOnState(); 
                    renderPreview();
                });

                // (変更) 桁数入力が変更されたとき、最小化がチェックされていれば再実行
                decimalPlacesInput.addEventListener('input', () => {
                    if (minimizeCheckbox.checked) {
                        // (変更) decimalPlacesInput.value から桁数を取得
                        const digits = decimalPlacesInput.value;
                        editor.value = minifySvg(originalSvgContent, digits);
                        renderPreview(); // プレビューを更新
                    }
                });
            }

            function initPreviewControls() {
                previewBgPicker.addEventListener('input', (e) => {
                    setPreviewBackground(e.target.value);
                    renderPreview(); 
                });
                gridColsInput.addEventListener('input', renderPreview);
                gridRowsInput.addEventListener('input', renderPreview);
                gridZSelect.addEventListener('change', renderPreview);
                gridColorPicker.addEventListener('input', renderPreview); 
            }

            function initFileHandlers() {
                loadButton.addEventListener('click', () => fileInput.click());

                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const svgContent = e.target.result;
                            editor.value = svgContent; 
                            
                            if (minimizeCheckbox.checked) {
                                minimizeCheckbox.checked = false;
                                editor.readOnly = false;
                                updateEditorTextColorBasedOnState(); 
                            }
                            renderPreview(); 
                        };
                        reader.readAsText(file);
                    }
                    event.target.value = null; 
                });
                
                saveButton.addEventListener('click', () => {
                    const svgContent = editor.value;
                    const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'edited.svg'; 
                    document.body.appendChild(a); 
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }

            // --- Resizer ---
            function initResizer() {
                const parentContainer = resizer.parentElement;

                const handleResizeStart = (e) => {
                    isResizing = true;
                    document.body.classList.add('resizing'); // テキスト選択無効
                    preview.style.pointerEvents = 'none'; 
                    e.preventDefault(); 
                };

                const handleResizeMove = (e) => {
                    if (!isResizing) return;

                    const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
                    const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
                    if (clientX === 0 && clientY === 0) return; 

                    const parentRect = parentContainer.getBoundingClientRect();
                    const resizerRect = resizer.getBoundingClientRect();
                    const isDesktop = window.innerWidth >= 768; // Tailwind md

                    if (isDesktop) {
                        // 左右リサイズ
                        const gap = resizerRect.width;
                        const totalWidth = parentRect.width - gap;
                        let newPreviewWidth = clientX - parentRect.left - (gap / 2);

                        if (newPreviewWidth < MIN_PANEL_SIZE) newPreviewWidth = MIN_PANEL_SIZE;
                        
                        const newEditorWidth = totalWidth - newPreviewWidth;
                        if (newEditorWidth < MIN_PANEL_SIZE) {
                            newPreviewWidth = totalWidth - MIN_PANEL_SIZE;
                        }

                        previewContainer.style.flexBasis = `${(newPreviewWidth / totalWidth) * 100}%`;
                        editorContainer.style.flexBasis = `${(newEditorWidth / totalWidth) * 100}%`;

                    } else {
                        // 上下リサイズ
                        const gap = resizerRect.height;
                        const totalHeight = parentRect.height - gap;
                        let newPreviewHeight = clientY - parentRect.top - (gap / 2);

                        if (newPreviewHeight < MIN_PANEL_SIZE) newPreviewHeight = MIN_PANEL_SIZE;

                        const newEditorHeight = totalHeight - newPreviewHeight;
                        if (newEditorHeight < MIN_PANEL_SIZE) {
                            newPreviewHeight = totalHeight - MIN_PANEL_SIZE;
                        }
                        
                        previewContainer.style.flexBasis = `${(newPreviewHeight / totalHeight) * 100}%`;
                        editorContainer.style.flexBasis = `${(newEditorHeight / totalHeight) * 100}%`;
                    }
                };

                const handleResizeEnd = () => {
                    isResizing = false;
                    document.body.classList.remove('resizing');
                    preview.style.pointerEvents = 'auto'; // 操作を元に戻す
                };

                // マウスイベント
                resizer.addEventListener('mousedown', handleResizeStart);
                document.addEventListener('mousemove', handleResizeMove);
                document.addEventListener('mouseup', handleResizeEnd);

                // タッチイベント
                resizer.addEventListener('touchstart', handleResizeStart, { passive: false });
                document.addEventListener('touchmove', handleResizeMove, { passive: false });
                document.addEventListener('touchend', handleResizeEnd);
                document.addEventListener('touchcancel', handleResizeEnd);
            }

            // --- Initialization ---

            // 初期スタイルの適用
            setEditorBackground(bgPicker.value);
            updateEditorTextColorBasedOnState(); 
            setEditorFontSize(fontSizeInput.value);
            setPreviewBackground(previewBgPicker.value); 

            // ページ読み込み時に最初のプレビューを実行
            renderPreview();

            // 各機能のイベントリスナーを初期化
            initEditorControls();
            initPreviewControls();
            initPanZoom();
            initFileHandlers();
            initSnippets();
            initResizer();

        });
    </script>

</body>
</html>


